============================= test session starts ==============================
platform linux -- Python 3.11.0rc1, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/ubuntu/brikk-infrastructure
plugins: anyio-4.10.0, cov-7.0.0
collected 289 items

tests/auth/test_api_key_rotation.py FF                                   [  0%]
tests/auth/test_hmac_auth.py ..........................FFFFFFFFFFF       [ 13%]
tests/auth/test_idempotency.py .........F.                               [ 17%]
tests/examples/test_python_agent.py ...                                  [ 18%]
tests/smoke/test_app_startup.py sssssssss...                             [ 22%]
tests/smoke/test_coordination_api.py sssssssssss                         [ 26%]
tests/test_basic.py ...F.FF....                                          [ 30%]
tests/test_billing_portal.py ..........                                  [ 33%]
tests/test_billing_portal_stripe13.py .F.                                [ 34%]
tests/test_coordination_auth.py FFFFFFFF..FFF                            [ 39%]
tests/test_coordination_stub.py FFFFFF.F......FF..F                      [ 45%]
tests/test_coordination_v1.py .FF                                        [ 46%]
tests/test_discovery_v1.py FFF.F                                         [ 48%]
tests/test_economy_api_v1.py F                                           [ 48%]
tests/test_economy_db_v1.py .F.                                          [ 49%]
tests/test_envelope_uuid_validation.py .......                           [ 52%]
tests/test_envelope_validation.py FFF.F..F.F.FF..F..FFFFFF               [ 60%]
tests/test_health.py .....FF...F........FF.                              [ 68%]
tests/test_integrations_v1.py FFFFF                                      [ 69%]
tests/test_logging_context.py .....F...F...........                      [ 77%]
tests/test_metrics.py .....                                              [ 78%]
tests/test_performance_v1.py ....                                        [ 80%]
tests/test_rate_limit.py .............FFFFFFF..                          [ 87%]
tests/test_request_guards.py ........F.........                          [ 94%]
tests/test_smoke.py .F.F                                                 [ 95%]
tests/test_stripe_13_compatibility.py .........                          [ 98%]
tests/test_workflows_v1.py ....                                          [100%]

=================================== FAILURES ===================================
___________________ TestApiKeyRotation.test_api_key_creation ___________________

self = <tests.auth.test_api_key_rotation.TestApiKeyRotation object at 0x7f69f46e5050>
app = <Flask 'tests.auth.test_api_key_rotation'>
test_org = <Organization Test Organization (test-org)>
test_agent = <Agent 635d3234-5955-4cd3-8bc0-294cd3048765 'Test Agent for Rotation'>

    def test_api_key_creation(self, app, test_org, test_agent):
        """Test API key creation with proper encryption."""
        with app.app_context():
            with patch.dict(
                os.environ, {"BRIKK_ENCRYPTION_KEY": "test_key_32_bytes_long_for_fernet"}
            ):
                api_key, secret = ApiKey.create_api_key(
                    organization_id=test_org.id,
                    name="Test Key for Rotation",
                    agent_id=test_agent.id,
                )
    
                assert api_key.key_id.startswith("bk_")
                assert len(secret) >= 32  # Minimum secret length
                assert api_key.organization_id == test_org.id
                assert api_key.agent_id == test_agent.id
                assert api_key.is_valid()
    
                # Verify secret can be decrypted
>               decrypted_secret = api_key.decrypt_secret()
                                   ^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'ApiKey' object has no attribute 'decrypt_secret'

tests/auth/test_api_key_rotation.py:94: AttributeError
___________________ TestApiKeyRotation.test_api_key_rotation ___________________

self = <tests.auth.test_api_key_rotation.TestApiKeyRotation object at 0x7f69f46e5f50>
app = <Flask 'tests.auth.test_api_key_rotation'>
test_org = <Organization Test Organization (test-org)>
test_agent = <Agent 7754ddd7-3b39-40dd-8fab-5088b11e9278 'Test Agent for Rotation'>

    def test_api_key_rotation(self, app, test_org, test_agent):
        """Test API key secret rotation."""
        with app.app_context():
            with patch.dict(
                os.environ, {"BRIKK_ENCRYPTION_KEY": "test_key_32_bytes_long_for_fernet"}
            ):
                # Create initial API key
                api_key, original_secret = ApiKey.create_api_key(
                    organization_id=test_org.id,
                    name="Test Key for Rotation",
                    agent_id=test_agent.id,
                )
    
                original_key_id = api_key.key_id
    
                # Rotate secret
>               new_secret = api_key.rotate_secret()
                             ^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'ApiKey' object has no attribute 'rotate_secret'

tests/auth/test_api_key_rotation.py:113: AttributeError
________ TestAuthMiddleware.test_authenticate_request_feature_disabled _________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7f69f37a17d0>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7f69f0a83990>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:39.680527+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:39.680661+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
{"timestamp": "2025-10-13T03:32:40.368833+00:00", "level": "WARNING", "logger": "brikk.monitoring", "message": "Redis not available for metrics storage: Error 111 connecting to localhost:6379. Connection refused.", "module": "structured_logging", "function": "_log_with_context", "line": 85}
_________ TestAuthMiddleware.test_authenticate_request_missing_headers _________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7f69f37a1e90>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7f69f04e1ed0>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:40.537114+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:40.537258+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
________ TestAuthMiddleware.test_authenticate_request_invalid_timestamp ________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7f69f37a2550>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7f69f079ffd0>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:40.692523+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:40.692689+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_________ TestAuthMiddleware.test_authenticate_request_invalid_api_key _________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7f69f37a2c10>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7f69f08c8150>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:40.952189+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:40.952327+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
__________ TestAuthMiddleware.test_check_idempotency_feature_disabled __________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7f69f37a32d0>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7f69f0a85fd0>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:41.107907+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:41.108037+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
______________ TestAuthMiddleware.test_check_idempotency_no_auth _______________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7f69f379d5d0>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7f69f0699a10>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:41.364754+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:41.364879+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
______________ TestAuthMiddleware.test_check_idempotency_success _______________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7f69f37a2390>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7f69f03fb6d0>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:41.519912+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:41.520039+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_______________ TestAuthMiddleware.test_check_idempotency_replay _______________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7f69f37a1d90>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7f69f07f1910>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:41.675799+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:41.675926+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
___________________ TestAuthMiddleware.test_set_auth_context ___________________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7f69f37a0e10>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7f69f092f250>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:41.932263+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:41.932390+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_______________ TestAuthMiddleware.test_log_auth_result_success ________________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7f69f37a3590>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7f69f0a94a50>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:42.089057+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:42.089183+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_______________ TestAuthMiddleware.test_log_auth_result_failure ________________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7f69f37a3990>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7f69f035fd50>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:42.246005+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:42.246130+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
___ TestIdempotencyService.test_process_request_idempotency_with_custom_key ____

self = <tests.auth.test_idempotency.TestIdempotencyService object at 0x7f69f37c0e90>
app = <Flask 'src.factory'>
idempotency_service = <src.services.idempotency.IdempotencyService object at 0x7f69f0a51990>
mock_redis = <MagicMock id='140092982226192'>

    def test_process_request_idempotency_with_custom_key(self, app: Flask, idempotency_service, mock_redis):
        """Test idempotency processing with custom idempotency key."""
        key_id = "bk_test_key"
        body_hash = "abc123"
        custom_key = "custom_idem_key"
    
        # No cached response
        mock_redis.get.return_value = None
    
        with app.app_context():
            should_process, response, status = idempotency_service.process_request_idempotency(
                key_id, body_hash, custom_key
            )
    
        assert should_process
        assert response is None
        assert status is None
    
        # Should check for custom idempotency key
        expected_idem_key = idempotency_service.generate_idempotency_key(key_id, "", custom_key)
>       mock_redis.get.assert_called_with(expected_idem_key)

tests/auth/test_idempotency.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='mock.get' id='140092985642640'>
args = ('idem:bk_test_key::custom_idem_key',), kwargs = {}
expected = call('idem:bk_test_key::custom_idem_key')
actual = call('idem:bk_test_key:abc123')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7f69f06b8220>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\nActual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: get('idem:bk_test_key::custom_idem_key')
E           Actual: get('idem:bk_test_key:abc123')

/usr/lib/python3.11/unittest/mock.py:923: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:42.707550+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:42.707645+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
__________________________ test_inbound_ping_endpoint __________________________

    def test_inbound_ping_endpoint():
        """Test the inbound ping endpoint."""
        app = create_app()
        with app.test_client() as client:
            response = client.get('/api/inbound/_ping')
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_basic.py:44: AssertionError
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:42.940442+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:42.940558+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
{"timestamp": "2025-10-13T03:32:42.966615+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/inbound/_ping", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "GET", "path": "/api/inbound/_ping", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:32:42.967092+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/inbound/_ping - 404 (0.33ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "069d5c43-3a8c-44f4-8991-129b8a37d129", "method": "GET", "path": "/api/inbound/_ping", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.33, "event_type": "request_end", "status_code": 404, "content_length": 207}
_______________________ test_database_url_normalization ________________________

    def test_database_url_normalization():
        """Test the database URL normalization function."""
    
    
        # Test postgres:// to postgresql+psycopg:// conversion
        postgres_url = "postgres://user:pass@host:5432/db"
>       normalized = _normalize_db_url(postgres_url)
                     ^^^^^^^^^^^^^^^^^
E       NameError: name '_normalize_db_url' is not defined

tests/test_basic.py:76: NameError
_________________________ test_blueprint_registration __________________________

    def test_blueprint_registration():
        """Test that blueprints are properly registered."""
        app = create_app()
    
        # Check that blueprints are registered
        blueprint_names = [bp.name for bp in app.blueprints.values()]
    
        # These blueprints should be registered based on the main.py file
        expected_blueprints = ['inbound']
    
        for expected_bp in expected_blueprints:
>           assert expected_bp in blueprint_names, f"Blueprint {expected_bp} not registered"
E           AssertionError: Blueprint inbound not registered
E           assert 'inbound' in ['auth', 'app', 'agents_bp', 'billing', 'coordination_bp', 'coordination_v1', ...]

tests/test_basic.py:106: AssertionError
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:43.001190+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:43.001276+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
____________________ test_billing_portal_request_validation ____________________

client = <FlaskClient <Flask 'src.factory'>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f69f06732d0>

    def test_billing_portal_request_validation(client, monkeypatch):
        """Test request payload validation and processing."""
        os.environ["STRIPE_SECRET_KEY"] = "sk_test_dummy"
    
        # Mock successful Stripe session creation
        mock_stripe = MagicMock()
        mock_session = MagicMock()
        mock_session.url = "https://billing.stripe.com/session/test"
        mock_stripe.billing_portal.Session.create.return_value = mock_session
    
        with patch('src.routes.billing.stripe', mock_stripe):
            # Test with valid customer_id
            resp = client.post("/api/billing/portal", json={"customer_id": "cus_valid"})
    
>           assert resp.status_code == 200
E           assert 502 == 200
E            +  where 502 = <WrapperTestResponse streamed [502 BAD GATEWAY]>.status_code

tests/test_billing_portal_stripe13.py:68: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:43.496768+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:43.496853+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:43.521070+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/billing/portal", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/billing/portal", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 28}
{"timestamp": "2025-10-13T03:32:43.521387+00:00", "level": "INFO", "logger": "stripe", "message": "message='Request to Stripe api' method=post url=https://api.stripe.com/v1/billing_portal/sessions", "module": "_util", "function": "log_info", "line": 127, "request_id": "719439e6-5425-4b08-bec7-50789be25c2f", "method": "POST", "path": "/api/billing/portal", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.23}
{"timestamp": "2025-10-13T03:32:43.524540+00:00", "level": "INFO", "logger": "stripe", "message": "message='Stripe API response' path=https://api.stripe.com/v1/billing_portal/sessions response_code=401", "module": "_util", "function": "log_info", "line": 127, "request_id": "719439e6-5425-4b08-bec7-50789be25c2f", "method": "POST", "path": "/api/billing/portal", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 3.39}
{"timestamp": "2025-10-13T03:32:43.524700+00:00", "level": "INFO", "logger": "stripe", "message": "error_code=None error_message='Invalid API Key provided: sk_test_*ummy' error_param=None error_type=invalid_request_error message='Stripe v1 API error received'", "module": "_util", "function": "log_info", "line": 127, "request_id": "719439e6-5425-4b08-bec7-50789be25c2f", "method": "POST", "path": "/api/billing/portal", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 3.54}
{"timestamp": "2025-10-13T03:32:43.524881+00:00", "level": "ERROR", "logger": "src.factory", "message": "Stripe error: Invalid API Key provided: sk_test_*ummy", "module": "app", "function": "billing_portal", "line": 145, "request_id": "719439e6-5425-4b08-bec7-50789be25c2f", "method": "POST", "path": "/api/billing/portal", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 3.72}
{"timestamp": "2025-10-13T03:32:43.525114+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/billing/portal - 502 (3.9ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "719439e6-5425-4b08-bec7-50789be25c2f", "method": "POST", "path": "/api/billing/portal", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 3.9, "event_type": "request_end", "status_code": 502, "content_length": 66}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/billing/portal
INFO     stripe:_util.py:127 message='Request to Stripe api' method=post url=https://api.stripe.com/v1/billing_portal/sessions
INFO     stripe:_util.py:127 message='Stripe API response' path=https://api.stripe.com/v1/billing_portal/sessions response_code=401
INFO     stripe:_util.py:127 error_code=None error_message='Invalid API Key provided: sk_test_*ummy' error_param=None error_type=invalid_request_error message='Stripe v1 API error received'
ERROR    src.factory:app.py:145 Stripe error: Invalid API Key provided: sk_test_*ummy
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/billing/portal - 502 (3.9ms)
__________ TestCoordinationAuth.test_coordination_endpoint_flags_off ___________

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f3477050>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    def test_coordination_endpoint_flags_off(self, client, valid_envelope):
        """Test coordination endpoint with all feature flags OFF."""
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
>           assert response.status_code == 202
E           assert 422 == 202
E            +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_auth.py:104: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:43.555521+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:43.555607+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:43.580707+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:32:43.582024+00:00", "level": "ERROR", "logger": "src.services.rate_limit", "message": "Failed to connect to Redis: Error 111 connecting to localhost:6379. Connection refused.", "module": "rate_limit", "function": "_create_redis_client", "line": 94, "request_id": "e5741912-2471-4e93-8c7b-9b4227628b30", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 1.23}
{"timestamp": "2025-10-13T03:32:43.582987+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (2.13ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "e5741912-2471-4e93-8c7b-9b4227628b30", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 2.13, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
ERROR    src.services.rate_limit:rate_limit.py:94 Failed to connect to Redis: Error 111 connecting to localhost:6379. Connection refused.
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (2.13ms)
__________ TestCoordinationAuth.test_coordination_endpoint_valid_hmac __________

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f34776d0>
mock_query = <MagicMock name='query' id='140092980742480'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}
mock_api_key = <MagicMock name='query.filter_by().first()' id='140092975994512'>

    @patch('src.models.api_key.ApiKey.query')
    def test_coordination_endpoint_valid_hmac(self, mock_query, client, valid_envelope, mock_api_key):
        """Test coordination endpoint with valid HMAC authentication."""
        mock_query.filter_by.return_value.first.return_value = mock_api_key
    
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            body = json.dumps(valid_envelope).encode()
>           headers = self.create_hmac_headers(
                'POST', '/api/v1/coordination', body, 'test-secret-key',
                valid_envelope['message_id']
            )

tests/test_coordination_auth.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f34776d0>
method = 'POST', path = '/api/v1/coordination'
body = b'{"version": "1.0", "message_id": "01234567-89ab-cdef-0123-456789abcdef", "ts": "2025-10-13T03:32:43.614475+00:00", "...: {"agent_id": "test-agent"}, "recipient": {"agent_id": "target-agent"}, "payload": {"test": "data"}, "ttl_ms": 30000}'
secret = 'test-secret-key', message_id = '01234567-89ab-cdef-0123-456789abcdef'
timestamp = '2025-10-13T03:32:43.616715+00:00'

    def create_hmac_headers(self, method: str, path: str, body: bytes,
                          secret: str, message_id: str = "",
                          timestamp: str = None) -> dict:
        """Create valid HMAC headers for testing."""
        if timestamp is None:
            timestamp = datetime.now(timezone.utc).isoformat()
    
>       signature = HMACSecurityService.generate_signature(
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            method=method,
            path=path,
            timestamp=timestamp,
            body=body,
            secret=secret,
            message_id=message_id
        )
E       AttributeError: type object 'HMACSecurityService' has no attribute 'generate_signature'

tests/test_coordination_auth.py:76: AttributeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:43.591159+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:43.591246+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_______ TestCoordinationAuth.test_coordination_endpoint_missing_headers ________

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f34685d0>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    def test_coordination_endpoint_missing_headers(self, client, valid_envelope):
        """Test coordination endpoint with missing HMAC headers."""
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
>           assert response.status_code == 400
E           assert 401 == 400
E            +  where 401 = <WrapperTestResponse streamed [401 UNAUTHORIZED]>.status_code

tests/test_coordination_auth.py:154: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:43.626680+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:43.626772+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:43.651038+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:32:43.651435+00:00", "level": "WARNING", "logger": "brikk.auth", "message": "Authentication hmac_verification: failure", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "07f858ba-f3dd-40f2-8762-713b54c4e218", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.3, "event_type": "auth_event", "auth_event": "hmac_verification", "success": false, "failure_reason": "unauthorized", "status_code": 401}
{"timestamp": "2025-10-13T03:32:43.651545+00:00", "level": "WARNING", "logger": "brikk.coordination", "message": "Authentication hmac_verification: failure", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "07f858ba-f3dd-40f2-8762-713b54c4e218", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.39, "event_type": "auth_event", "auth_event": "hmac_verification", "success": false, "failure_reason": "unauthorized"}
{"timestamp": "2025-10-13T03:32:43.651802+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 401 (0.6ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "760630e4-9a68-430a-9dc2-eb975f0dade2", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.6, "event_type": "request_end", "status_code": 401, "content_length": 158}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
WARNING  brikk.auth:structured_logging.py:85 Authentication hmac_verification: failure
WARNING  brikk.coordination:structured_logging.py:85 Authentication hmac_verification: failure
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 401 (0.6ms)
_______ TestCoordinationAuth.test_coordination_endpoint_invalid_api_key ________

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f3477b50>
mock_query = <MagicMock name='query' id='140092974648784'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    @patch('src.models.api_key.ApiKey.query')
    def test_coordination_endpoint_invalid_api_key(self, mock_query, client, valid_envelope):
        """Test coordination endpoint with invalid API key."""
        mock_query.filter_by.return_value.first.return_value = None
    
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            body = json.dumps(valid_envelope).encode()
>           headers = self.create_hmac_headers(
                'POST', '/api/v1/coordination', body, 'test-secret-key'
            )

tests/test_coordination_auth.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f3477b50>
method = 'POST', path = '/api/v1/coordination'
body = b'{"version": "1.0", "message_id": "01234567-89ab-cdef-0123-456789abcdef", "ts": "2025-10-13T03:32:43.682772+00:00", "...: {"agent_id": "test-agent"}, "recipient": {"agent_id": "target-agent"}, "payload": {"test": "data"}, "ttl_ms": 30000}'
secret = 'test-secret-key', message_id = ''
timestamp = '2025-10-13T03:32:43.683968+00:00'

    def create_hmac_headers(self, method: str, path: str, body: bytes,
                          secret: str, message_id: str = "",
                          timestamp: str = None) -> dict:
        """Create valid HMAC headers for testing."""
        if timestamp is None:
            timestamp = datetime.now(timezone.utc).isoformat()
    
>       signature = HMACSecurityService.generate_signature(
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            method=method,
            path=path,
            timestamp=timestamp,
            body=body,
            secret=secret,
            message_id=message_id
        )
E       AttributeError: type object 'HMACSecurityService' has no attribute 'generate_signature'

tests/test_coordination_auth.py:76: AttributeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:43.658780+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:43.658868+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
______ TestCoordinationAuth.test_coordination_endpoint_invalid_signature _______

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f3477f90>
mock_query = <MagicMock name='query' id='140092975295440'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}
mock_api_key = <MagicMock name='query.filter_by().first()' id='140092975224016'>

    @patch('src.models.api_key.ApiKey.query')
    def test_coordination_endpoint_invalid_signature(self, mock_query, client, valid_envelope, mock_api_key):
        """Test coordination endpoint with invalid HMAC signature."""
        mock_query.filter_by.return_value.first.return_value = mock_api_key
    
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            body = json.dumps(valid_envelope).encode()
            headers = {
                'X-Brikk-Key': 'test-key-id',
                'X-Brikk-Timestamp': datetime.now(timezone.utc).isoformat(),
                'X-Brikk-Signature': 'invalid-signature',
                'Content-Type': 'application/json'
            }
    
            response = client.post(
                '/api/v1/coordination',
                data=body,
                headers=headers
            )
    
            assert response.status_code == 401
            data = response.get_json()
            assert data['code'] == 'unauthorized'
>           assert 'Invalid HMAC signature' in data['message']
E           AssertionError: assert 'Invalid HMAC signature' in 'Authentication required. Please log in or provide valid HMAC headers.'

tests/test_coordination_auth.py:211: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:43.692699+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:43.692790+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:43.720098+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:32:43.720517+00:00", "level": "WARNING", "logger": "brikk.auth", "message": "Authentication hmac_verification: failure", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "6bf664b6-cbd9-4f86-a9a1-f26c8f19c7d5", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.32, "event_type": "auth_event", "auth_event": "hmac_verification", "success": false, "failure_reason": "unauthorized", "status_code": 401}
{"timestamp": "2025-10-13T03:32:43.720629+00:00", "level": "WARNING", "logger": "brikk.coordination", "message": "Authentication hmac_verification: failure", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "6bf664b6-cbd9-4f86-a9a1-f26c8f19c7d5", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.42, "event_type": "auth_event", "auth_event": "hmac_verification", "success": false, "failure_reason": "unauthorized"}
{"timestamp": "2025-10-13T03:32:43.720902+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 401 (0.65ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "375eb2f6-61bb-48dc-8317-8209bf903dca", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.65, "event_type": "request_end", "status_code": 401, "content_length": 158}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
WARNING  brikk.auth:structured_logging.py:85 Authentication hmac_verification: failure
WARNING  brikk.coordination:structured_logging.py:85 Authentication hmac_verification: failure
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 401 (0.65ms)
_______ TestCoordinationAuth.test_coordination_endpoint_timestamp_drift ________

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f3484410>
mock_query = <MagicMock name='query' id='140092973866512'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}
mock_api_key = <MagicMock name='query.filter_by().first()' id='140092973827600'>

    @patch('src.models.api_key.ApiKey.query')
    def test_coordination_endpoint_timestamp_drift(self, mock_query, client, valid_envelope, mock_api_key):
        """Test coordination endpoint with timestamp outside drift window."""
        mock_query.filter_by.return_value.first.return_value = mock_api_key
    
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            # Create timestamp 400 seconds in the past (outside '+/-300s window)
            old_timestamp = (datetime.now(timezone.utc) - timedelta(seconds=400)).isoformat()
    
            body = json.dumps(valid_envelope).encode()
>           headers = self.create_hmac_headers(
                'POST', '/api/v1/coordination', body, 'test-secret-key',
                valid_envelope['message_id'], old_timestamp
            )

tests/test_coordination_auth.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f3484410>
method = 'POST', path = '/api/v1/coordination'
body = b'{"version": "1.0", "message_id": "01234567-89ab-cdef-0123-456789abcdef", "ts": "2025-10-13T03:32:43.753763+00:00", "...: {"agent_id": "test-agent"}, "recipient": {"agent_id": "target-agent"}, "payload": {"test": "data"}, "ttl_ms": 30000}'
secret = 'test-secret-key', message_id = '01234567-89ab-cdef-0123-456789abcdef'
timestamp = '2025-10-13T03:26:03.755723+00:00'

    def create_hmac_headers(self, method: str, path: str, body: bytes,
                          secret: str, message_id: str = "",
                          timestamp: str = None) -> dict:
        """Create valid HMAC headers for testing."""
        if timestamp is None:
            timestamp = datetime.now(timezone.utc).isoformat()
    
>       signature = HMACSecurityService.generate_signature(
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            method=method,
            path=path,
            timestamp=timestamp,
            body=body,
            secret=secret,
            message_id=message_id
        )
E       AttributeError: type object 'HMACSecurityService' has no attribute 'generate_signature'

tests/test_coordination_auth.py:76: AttributeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:43.728838+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:43.728930+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
______ TestCoordinationAuth.test_coordination_endpoint_idempotent_replay _______

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f3484850>
mock_idempotency = <MagicMock name='process_request_idempotency' id='140092984968080'>
mock_query = <MagicMock name='query' id='140092974211472'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}
mock_api_key = <MagicMock name='query.filter_by().first()' id='140092974443536'>

    @patch('src.models.api_key.ApiKey.query')
    @patch('src.services.idempotency.IdempotencyService.process_request_idempotency')
    def test_coordination_endpoint_idempotent_replay(self, mock_idempotency, mock_query,
                                                   client, valid_envelope, mock_api_key):
        """Test coordination endpoint with idempotent replay (same request)."""
        mock_query.filter_by.return_value.first.return_value = mock_api_key
    
        # Mock idempotency service to return cached response
        cached_response = {
            "status": "accepted",
            "echo": {"message_id": valid_envelope['message_id']}
        }
        mock_idempotency.return_value = (False, cached_response, 202)
    
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'true'
        }):
            body = json.dumps(valid_envelope).encode()
>           headers = self.create_hmac_headers(
                'POST', '/api/v1/coordination', body, 'test-secret-key',
                valid_envelope['message_id']
            )

tests/test_coordination_auth.py:267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f3484850>
method = 'POST', path = '/api/v1/coordination'
body = b'{"version": "1.0", "message_id": "01234567-89ab-cdef-0123-456789abcdef", "ts": "2025-10-13T03:32:43.789794+00:00", "...: {"agent_id": "test-agent"}, "recipient": {"agent_id": "target-agent"}, "payload": {"test": "data"}, "ttl_ms": 30000}'
secret = 'test-secret-key', message_id = '01234567-89ab-cdef-0123-456789abcdef'
timestamp = '2025-10-13T03:32:43.791986+00:00'

    def create_hmac_headers(self, method: str, path: str, body: bytes,
                          secret: str, message_id: str = "",
                          timestamp: str = None) -> dict:
        """Create valid HMAC headers for testing."""
        if timestamp is None:
            timestamp = datetime.now(timezone.utc).isoformat()
    
>       signature = HMACSecurityService.generate_signature(
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            method=method,
            path=path,
            timestamp=timestamp,
            body=body,
            secret=secret,
            message_id=message_id
        )
E       AttributeError: type object 'HMACSecurityService' has no attribute 'generate_signature'

tests/test_coordination_auth.py:76: AttributeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:43.765073+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:43.765164+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_____ TestCoordinationAuth.test_coordination_endpoint_idempotency_conflict _____

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f3484c90>
mock_idempotency = <MagicMock name='process_request_idempotency' id='140092976863184'>
mock_query = <MagicMock name='query' id='140092973153488'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}
mock_api_key = <MagicMock name='query.filter_by().first()' id='140092973128336'>

    @patch('src.models.api_key.ApiKey.query')
    @patch('src.services.idempotency.IdempotencyService.process_request_idempotency')
    def test_coordination_endpoint_idempotency_conflict(self, mock_idempotency, mock_query,
                                                      client, valid_envelope, mock_api_key):
        """Test coordination endpoint with idempotency conflict (same key, different body)."""
        mock_query.filter_by.return_value.first.return_value = mock_api_key
    
        # Mock idempotency service to return conflict
        mock_idempotency.return_value = (False, {'code': 'idempotency_conflict', 'message': 'Idempotency key conflicts with previous request'}, 409)
    
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'true'
        }):
            body = json.dumps(valid_envelope).encode()
>           headers = self.create_hmac_headers(
                'POST', '/api/v1/coordination', body, 'test-secret-key',
                valid_envelope['message_id']
            )

tests/test_coordination_auth.py:298: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f3484c90>
method = 'POST', path = '/api/v1/coordination'
body = b'{"version": "1.0", "message_id": "01234567-89ab-cdef-0123-456789abcdef", "ts": "2025-10-13T03:32:43.826323+00:00", "...: {"agent_id": "test-agent"}, "recipient": {"agent_id": "target-agent"}, "payload": {"test": "data"}, "ttl_ms": 30000}'
secret = 'test-secret-key', message_id = '01234567-89ab-cdef-0123-456789abcdef'
timestamp = '2025-10-13T03:32:43.828516+00:00'

    def create_hmac_headers(self, method: str, path: str, body: bytes,
                          secret: str, message_id: str = "",
                          timestamp: str = None) -> dict:
        """Create valid HMAC headers for testing."""
        if timestamp is None:
            timestamp = datetime.now(timezone.utc).isoformat()
    
>       signature = HMACSecurityService.generate_signature(
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            method=method,
            path=path,
            timestamp=timestamp,
            body=body,
            secret=secret,
            message_id=message_id
        )
E       AttributeError: type object 'HMACSecurityService' has no attribute 'generate_signature'

tests/test_coordination_auth.py:76: AttributeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:43.801359+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:43.801451+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
____________ TestCoordinationAuth.test_coordination_health_endpoint ____________

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f3485fd0>
client = <FlaskClient <Flask 'src.factory'>>

    def test_coordination_health_endpoint(self, client):
        """Test coordination health check endpoint."""
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'true',
            'BRIKK_ALLOW_UUID4': 'false'
        }):
            response = client.get('/api/v1/coordination/health')
    
            assert response.status_code == 200
            data = response.get_json()
            assert data['status'] == 'healthy'
            assert data['service'] == 'coordination-api'
            assert data['version'] == '1.0'
            assert 'features' in data
>           assert data['features']['per_org_keys'] is True
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'per_org_keys'

tests/test_coordination_auth.py:376: KeyError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:44.010747+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:44.010832+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:44.036058+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/v1/coordination/health", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "GET", "path": "/api/v1/coordination/health", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:32:44.036540+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/v1/coordination/health - 200 (0.34ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "75e1eda9-8d1f-4191-a489-3fa3826a4515", "method": "GET", "path": "/api/v1/coordination/health", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.34, "event_type": "request_end", "status_code": 200, "content_length": 183}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: GET /api/v1/coordination/health
INFO     brikk.requests:structured_logging.py:85 Request completed: GET /api/v1/coordination/health - 200 (0.34ms)
______________ TestCoordinationAuth.test_security_headers_present ______________

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f3486690>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    def test_security_headers_present(self, client, valid_envelope):
        """Test that security headers are present in responses."""
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
>           assert response.status_code == 202
E           assert 422 == 202
E            +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_auth.py:392: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:44.043741+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:44.043829+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:44.068144+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:32:44.068790+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (0.5ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "94acf019-3b5b-443f-919a-6d504b8a2392", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.5, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (0.5ms)
_ TestCoordinationAuth.test_coordination_endpoint_with_custom_idempotency_key __

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f3486d10>
mock_query = <MagicMock name='query' id='140092983058960'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}
mock_api_key = <MagicMock name='query.filter_by().first()' id='140092974567248'>

    @patch('src.models.api_key.ApiKey.query')
    def test_coordination_endpoint_with_custom_idempotency_key(self, mock_query, client,
                                                             valid_envelope, mock_api_key):
        """Test coordination endpoint with custom Idempotency-Key header."""
        mock_query.filter_by.return_value.first.return_value = mock_api_key
    
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'true'
        }):
            body = json.dumps(valid_envelope).encode()
>           headers = self.create_hmac_headers(
                'POST', '/api/v1/coordination', body, 'test-secret-key',
                valid_envelope['message_id']
            )

tests/test_coordination_auth.py:414: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7f69f3486d10>
method = 'POST', path = '/api/v1/coordination'
body = b'{"version": "1.0", "message_id": "01234567-89ab-cdef-0123-456789abcdef", "ts": "2025-10-13T03:32:44.099441+00:00", "...: {"agent_id": "test-agent"}, "recipient": {"agent_id": "target-agent"}, "payload": {"test": "data"}, "ttl_ms": 30000}'
secret = 'test-secret-key', message_id = '01234567-89ab-cdef-0123-456789abcdef'
timestamp = '2025-10-13T03:32:44.101349+00:00'

    def create_hmac_headers(self, method: str, path: str, body: bytes,
                          secret: str, message_id: str = "",
                          timestamp: str = None) -> dict:
        """Create valid HMAC headers for testing."""
        if timestamp is None:
            timestamp = datetime.now(timezone.utc).isoformat()
    
>       signature = HMACSecurityService.generate_signature(
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            method=method,
            path=path,
            timestamp=timestamp,
            body=body,
            secret=secret,
            message_id=message_id
        )
E       AttributeError: type object 'HMACSecurityService' has no attribute 'generate_signature'

tests/test_coordination_auth.py:76: AttributeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:44.075768+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:44.075855+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
___________ TestCoordinationEndpoint.test_valid_request_returns_202 ____________

self = <tests.test_coordination_stub.TestCoordinationEndpoint object at 0x7f69f2ae5a50>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_headers = {'Content-Type': 'application/json', 'X-Brikk-Key': 'test-key-123', 'X-Brikk-Signature': 'test-signature-abc123', 'X-Brikk-Timestamp': '1696248600'}
valid_envelope = {'message_id': '59bd54fb-afae-4c76-964e-a0f5c2713b36', 'payload': {'action': 'coordinate', 'data': {'key': 'value'}}, 'recipient': {'agent_id': 'test-recipient-002'}, 'sender': {'agent_id': 'test-sender-001'}, ...}

    def test_valid_request_returns_202(self, client, valid_headers, valid_envelope):
        """Test that valid request returns 202 with echo."""
        response = client.post(
            '/api/v1/coordination',
            headers=valid_headers,
            json=valid_envelope
        )
    
>       assert response.status_code == 202
E       assert 422 == 202
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_stub.py:74: AssertionError
_____________ TestCoordinationEndpoint.test_minimal_valid_envelope _____________

self = <tests.test_coordination_stub.TestCoordinationEndpoint object at 0x7f69f2ae6110>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_headers = {'Content-Type': 'application/json', 'X-Brikk-Key': 'test-key-123', 'X-Brikk-Signature': 'test-signature-abc123', 'X-Brikk-Timestamp': '1696248600'}

    def test_minimal_valid_envelope(self, client, valid_headers):
        """Test that minimal valid envelope is accepted."""
        minimal_envelope = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "type": "command",
            "sender": {'agent_id': "sender-001"},
            "recipient": {'agent_id': "recipient-002"},
            "payload": {'action': "test"}
        }
    
        response = client.post(
            '/api/v1/coordination',
            headers=valid_headers,
            json=minimal_envelope
        )
    
>       assert response.status_code == 202
E       assert 422 == 202
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_stub.py:98: AssertionError
____________ TestCoordinationEndpoint.test_security_headers_present ____________

self = <tests.test_coordination_stub.TestCoordinationEndpoint object at 0x7f69f2ae6810>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_headers = {'Content-Type': 'application/json', 'X-Brikk-Key': 'test-key-123', 'X-Brikk-Signature': 'test-signature-abc123', 'X-Brikk-Timestamp': '1696248600'}
valid_envelope = {'message_id': 'f5c6f524-58b3-4612-a6a9-23991529445d', 'payload': {'action': 'coordinate', 'data': {'key': 'value'}}, 'recipient': {'agent_id': 'test-recipient-002'}, 'sender': {'agent_id': 'test-sender-001'}, ...}

    def test_security_headers_present(self, client, valid_headers, valid_envelope):
        """Test that security headers are present in response."""
        response = client.post(
            '/api/v1/coordination',
            headers=valid_headers,
            json=valid_envelope
        )
    
>       assert response.status_code == 202
E       assert 422 == 202
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_stub.py:110: AssertionError
______ TestRequestGuardsIntegration.test_missing_content_type_returns_415 ______

self = <tests.test_coordination_stub.TestRequestGuardsIntegration object at 0x7f69f2ae7110>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_envelope = {'message_id': 'ae440632-0e75-4a0a-a182-2dcd486c0eec', 'payload': {'action': 'coordinate', 'data': {'key': 'value'}}, 'recipient': {'agent_id': 'test-recipient-002'}, 'sender': {'agent_id': 'test-sender-001'}, ...}

    def test_missing_content_type_returns_415(self, client, valid_envelope):
        """Test that missing Content-Type returns 415."""
        headers = {
            'X-Brikk-Key': 'test-key',
            'X-Brikk-Timestamp': '1696248600',
            'X-Brikk-Signature': 'test-signature'
        }
    
        response = client.post(
            '/api/v1/coordination',
            headers=headers,
            data=json.dumps(valid_envelope)
        )
    
>       assert response.status_code == 415
E       assert 400 == 415
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code

tests/test_coordination_stub.py:135: AssertionError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/home/ubuntu/brikk-infrastructure/src/routes/coordination.py", line 232, in coordination_endpoint
    json_data = request.get_json()
                ^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/werkzeug/wrappers/request.py", line 604, in get_json
    return self.on_json_loading_failed(None)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/flask/wrappers.py", line 214, in on_json_loading_failed
    return super().on_json_loading_failed(e)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/werkzeug/wrappers/request.py", line 647, in on_json_loading_failed
    raise UnsupportedMediaType(
werkzeug.exceptions.UnsupportedMediaType: 415 Unsupported Media Type: Did not attempt to load JSON data because the request Content-Type was not 'application/json'.
_____ TestRequestGuardsIntegration.test_missing_brikk_headers_returns_400 ______

self = <tests.test_coordination_stub.TestRequestGuardsIntegration object at 0x7f69f2ae77d0>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_envelope = {'message_id': 'd4f09d1e-34b7-4d9e-9999-a3d07a6d5c12', 'payload': {'action': 'coordinate', 'data': {'key': 'value'}}, 'recipient': {'agent_id': 'test-recipient-002'}, 'sender': {'agent_id': 'test-sender-001'}, ...}

    def test_missing_brikk_headers_returns_400(self, client, valid_envelope):
        """Test that missing Brikk headers return 400."""
        headers = {'Content-Type': 'application/json'}
    
        response = client.post(
            '/api/v1/coordination',
            headers=headers,
            json=valid_envelope
        )
    
>       assert response.status_code == 400
E       assert 422 == 400
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_stub.py:150: AssertionError
_________ TestRequestGuardsIntegration.test_oversized_body_returns_413 _________

self = <tests.test_coordination_stub.TestRequestGuardsIntegration object at 0x7f69f2ae7e90>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_headers = {'Content-Type': 'application/json', 'X-Brikk-Key': 'test-key-123', 'X-Brikk-Signature': 'test-signature-abc123', 'X-Brikk-Timestamp': '1696248600'}

    def test_oversized_body_returns_413(self, client, valid_headers):
        """Test that oversized request body returns 413."""
        # Create large payload
        large_payload = {'data': "x" * (256 * 1024 + 1000)}  # >256KB
        large_envelope = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "type": "command",
            "sender": {'agent_id': "sender-001"},
            "recipient": {'agent_id': "recipient-002"},
            "payload": large_payload
        }
    
        response = client.post(
            '/api/v1/coordination',
            headers=valid_headers,
            json=large_envelope
        )
    
>       assert response.status_code == 413
E       assert 422 == 413
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_stub.py:177: AssertionError
__ TestEnvelopeValidationIntegration.test_missing_required_fields_returns_422 __

self = <tests.test_coordination_stub.TestEnvelopeValidationIntegration object at 0x7f69f2afce90>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_headers = {'Content-Type': 'application/json', 'X-Brikk-Key': 'test-key-123', 'X-Brikk-Signature': 'test-signature-abc123', 'X-Brikk-Timestamp': '1696248600'}

    def test_missing_required_fields_returns_422(self, client, valid_headers):
        """Test that missing required fields return 422."""
        incomplete_envelope = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            # Missing sender, recipient, payload, type
        }
    
        response = client.post(
            '/api/v1/coordination',
            headers=valid_headers,
            json=incomplete_envelope
        )
    
        assert response.status_code == 422
        data = response.get_json()
        assert data['code'] == 'validation_error'
        assert 'details' in data
    
        # Check that all missing fields are reported
        details_str = ' '.join(str(d) for d in data['details'])
        assert 'sender' in details_str
        assert 'recipient' in details_str
        assert 'payload' in details_str
>       assert 'type' in details_str
E       AssertionError: assert 'type' in 'message_id: Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. sender: Field required recipient: Field required payload: Field required'

tests/test_coordination_stub.py:234: AssertionError
_________ TestErrorHandling.test_error_responses_have_security_headers _________

self = <tests.test_coordination_stub.TestErrorHandling object at 0x7f69f2908190>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_headers = {'Content-Type': 'application/json', 'X-Brikk-Key': 'test-key-123', 'X-Brikk-Signature': 'test-signature-abc123', 'X-Brikk-Timestamp': '1696248600'}

    def test_error_responses_have_security_headers(self, client, valid_headers):
        """Test that error responses include security headers."""
        response = client.post(
            '/api/v1/coordination',
            headers={'Content-Type': 'text/plain'},  # Wrong content type
            data='test'
        )
    
>       assert response.status_code == 415
E       assert 400 == 415
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code

tests/test_coordination_stub.py:335: AssertionError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/home/ubuntu/brikk-infrastructure/src/routes/coordination.py", line 232, in coordination_endpoint
    json_data = request.get_json()
                ^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/werkzeug/wrappers/request.py", line 604, in get_json
    return self.on_json_loading_failed(None)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/flask/wrappers.py", line 214, in on_json_loading_failed
    return super().on_json_loading_failed(e)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/werkzeug/wrappers/request.py", line 647, in on_json_loading_failed
    raise UnsupportedMediaType(
werkzeug.exceptions.UnsupportedMediaType: 415 Unsupported Media Type: Did not attempt to load JSON data because the request Content-Type was not 'application/json'.
____________ TestHealthCheckEndpoint.test_health_check_returns_200 _____________

self = <tests.test_coordination_stub.TestHealthCheckEndpoint object at 0x7f69f2908a90>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>

    def test_health_check_returns_200(self, client):
        """Test that health check endpoint returns 200."""
        response = client.get('/api/v1/coordination/health')
    
        assert response.status_code == 200
        data = response.get_json()
    
        assert data['status'] == 'healthy'
        assert data['service'] == 'coordination-api'
>       assert data['version'] == '1.0-stub'
E       AssertionError: assert '1.0' == '1.0-stub'
E         
E         - 1.0-stub
E         + 1.0

tests/test_coordination_stub.py:355: AssertionError
_______________ TestMessageTypes.test_all_message_types_accepted _______________

self = <tests.test_coordination_stub.TestMessageTypes object at 0x7f69f2ae5bd0>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_headers = {'Content-Type': 'application/json', 'X-Brikk-Key': 'test-key-123', 'X-Brikk-Signature': 'test-signature-abc123', 'X-Brikk-Timestamp': '1696248600'}

    def test_all_message_types_accepted(self, client, valid_headers):
        """Test that all valid message types are accepted."""
        message_types = ["event", "command", "result", "error"]
    
        for msg_type in message_types:
            envelope = {
                "message_id": str(uuid.uuid4()),
                "ts": "2023-10-02T14:30:00Z",
                "type": msg_type,
                "sender": {'agent_id': "sender-001"},
                "recipient": {'agent_id': "recipient-002"},
                "payload": {'action': "test", 'type': msg_type}
            }
    
            response = client.post(
                '/api/v1/coordination',
                headers=valid_headers,
                json=envelope
            )
    
>           assert response.status_code == 202, f"Failed for message type: {msg_type}"
E           AssertionError: Failed for message type: event
E           assert 422 == 202
E            +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_stub.py:398: AssertionError
____________________ test_coordination_v1_invalid_signature ____________________

client = <FlaskClient <Flask 'src.factory'>>
org_and_key = (<Organization Test Org (test-org-6401d3ce-d339-4282-8e93-a0052aaca189)>, <ApiKey bk_nV_Gj_mTTOo1D*** (Test Key)>)

    def test_coordination_v1_invalid_signature(client, org_and_key):
        """Test failed call with invalid signature."""
        org, api_key = org_and_key
        timestamp = str(int(time.time()))
        body = {
            "version": "1.0",
            "message_id": str(uuid.uuid4()),
            "ts": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z",
            "type": "event",
            "sender": {"agent_id": "agent-1"},
            "recipient": {"agent_id": "agent-2"},
            "payload": {"foo": "bar"},
            "ttl_ms": 60000,
        }
        body_str = json.dumps(body)
        signature = "invalid-signature"
    
        headers = {
            "Content-Type": "application/json",
            "X-Brikk-Key": api_key.key_id,
            "X-Brikk-Timestamp": timestamp,
            "X-Brikk-Signature": signature,
        }
    
        response = client.post("/api/v1/coordination", headers=headers, data=body_str)
    
>       assert response.status_code == 401
E       assert 202 == 401
E        +  where 202 = <WrapperTestResponse streamed [202 ACCEPTED]>.status_code

tests/test_coordination_v1.py:131: AssertionError
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:44.401285+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 240}
{"timestamp": "2025-10-13T03:32:44.401848+00:00", "level": "INFO", "logger": "brikk.coordination", "message": "Coordination request processed successfully", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "782f71e4-7378-4512-8506-d07c96a49aaf", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.44, "event_type": "coordination_success", "message_id": "c0101cbd-d068-4053-9cac-c2b60bb91ebd", "message_type": "event", "sender_agent_id": "agent-1", "recipient_agent_id": "agent-2", "ttl_ms": 60000}
{"timestamp": "2025-10-13T03:32:44.402149+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 202 (0.67ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "067157ca-26da-4323-9010-817d120b8095", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.67, "event_type": "request_end", "status_code": 202, "content_length": 83}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.coordination:structured_logging.py:85 Coordination request processed successfully
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 202 (0.67ms)
_______________________ test_coordination_v1_idempotency _______________________

client = <FlaskClient <Flask 'src.factory'>>
org_and_key = (<Organization Test Org (test-org-13430c89-d15d-44dd-bd75-77cb0cf2b5cd)>, <ApiKey bk_yVmsCR1V_o5uR*** (Test Key)>)

    def test_coordination_v1_idempotency(client, org_and_key):
        """Test idempotency handling."""
        org, api_key = org_and_key
        timestamp = str(int(time.time()))
        body = {
            "version": "1.0",
            "message_id": str(uuid.uuid4()),
            "ts": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z",
            "type": "event",
            "sender": {"agent_id": "agent-1"},
            "recipient": {"agent_id": "agent-2"},
            "payload": {"foo": "bar"},
            "ttl_ms": 60000,
        }
        body_str = json.dumps(body)
        signature = generate_signature(timestamp, body_str, api_key.signing_secret)
        idempotency_key = f"idem-key-{uuid.uuid4()}"
    
        headers = {
            "Content-Type": "application/json",
            "X-Brikk-Key": api_key.key_id,
            "X-Brikk-Timestamp": timestamp,
            "X-Brikk-Signature": signature,
            "Idempotency-Key": idempotency_key,
        }
    
        # First request should succeed
        response1 = client.post("/api/v1/coordination", headers=headers, data=body_str)
        assert response1.status_code == 202
    
        # Second request with same idempotency key should be a replay
        response2 = client.post("/api/v1/coordination", headers=headers, data=body_str)
>       assert response2.status_code == 200  # Replay returns 200
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 202 == 200
E        +  where 202 = <WrapperTestResponse streamed [202 ACCEPTED]>.status_code

tests/test_coordination_v1.py:168: AssertionError
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:44.481324+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 240}
{"timestamp": "2025-10-13T03:32:44.481848+00:00", "level": "INFO", "logger": "brikk.coordination", "message": "Coordination request processed successfully", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "91e33ea3-4f87-41be-93ac-4550fd3e70c6", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.4, "event_type": "coordination_success", "message_id": "a984ef3d-7d17-4efd-9eba-399bb5a5f4c4", "message_type": "event", "sender_agent_id": "agent-1", "recipient_agent_id": "agent-2", "ttl_ms": 60000}
{"timestamp": "2025-10-13T03:32:44.482141+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 202 (0.63ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "e3e25d13-fd3c-4502-aef5-a8f7dc6ba821", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.63, "event_type": "request_end", "status_code": 202, "content_length": 83}
{"timestamp": "2025-10-13T03:32:44.482669+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "e3e25d13-fd3c-4502-aef5-a8f7dc6ba821", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 1.22, "event_type": "request_start", "content_length": 240}
{"timestamp": "2025-10-13T03:32:44.483083+00:00", "level": "INFO", "logger": "brikk.coordination", "message": "Coordination request processed successfully", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "fffba3c0-7009-43eb-a34b-989f010bb3a4", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.34, "event_type": "coordination_success", "message_id": "a984ef3d-7d17-4efd-9eba-399bb5a5f4c4", "message_type": "event", "sender_agent_id": "agent-1", "recipient_agent_id": "agent-2", "ttl_ms": 60000}
{"timestamp": "2025-10-13T03:32:44.483339+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 202 (0.54ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "9286a9d0-5dce-47bf-a3f0-db76d517a9b3", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.54, "event_type": "request_end", "status_code": 202, "content_length": 83}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.coordination:structured_logging.py:85 Coordination request processed successfully
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 202 (0.63ms)
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.coordination:structured_logging.py:85 Coordination request processed successfully
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 202 (0.54ms)
____________________________ test_register_service _____________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'agent_id': 'f03756b4-e354-4e07-a1d1-73985983e547', 'organization_id': '937eaab9-ce87-473d-a2f3-10ecd8a11ab5'}

    def test_register_service(client: FlaskClient, auth_headers: dict):
        """Test registering a new agent service"""
        service_data = {
            "service_name": "test-service",
            "service_url": "http://localhost:8080/service",
            "capabilities": ["data_processing", "nlp"]
        }
    
        response = client.post("/api/v1/discovery/register", json=service_data, headers=auth_headers)
>       assert response.status_code == 201
E       assert 422 == 201
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_discovery_v1.py:56: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:44.508586+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:44.508684+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:44.578484+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/discovery/register", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 124}
{"timestamp": "2025-10-13T03:32:44.579010+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/discovery/register - 422 (0.35ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "24756403-d771-4261-9020-67ed23abf9ef", "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.35, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/discovery/register
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/discovery/register - 422 (0.35ms)
____________________________ test_discover_services ____________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'agent_id': '270df715-18c7-46df-9ffa-65fdee862160', 'organization_id': '001cabac-321d-45c6-8576-2aea09f40c49'}

    def test_discover_services(client: FlaskClient, auth_headers: dict):
        """Test discovering available services"""
        # Register a service first
        client.post("/api/v1/discovery/register", json={
            "service_name": "test-service",
            "service_url": "http://localhost:8080/service",
            "capabilities": ["data_processing"]
        }, headers=auth_headers)
    
        # Discover all services
        response = client.get("/api/v1/discovery/discover", headers=auth_headers)
>       assert response.status_code == 200
E       assert 422 == 200
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_discovery_v1.py:70: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:44.598473+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:44.598570+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:44.666805+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/discovery/register", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 117}
{"timestamp": "2025-10-13T03:32:44.667298+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/discovery/register - 422 (0.33ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "4cb05374-0c48-4c3c-aeaa-e12fd188379e", "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.33, "event_type": "request_end", "status_code": 422, "content_length": 30}
{"timestamp": "2025-10-13T03:32:44.667798+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/v1/discovery/discover", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "4cb05374-0c48-4c3c-aeaa-e12fd188379e", "method": "GET", "path": "/api/v1/discovery/discover", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.89, "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:32:44.668174+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/v1/discovery/discover - 422 (0.25ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "2c323d0c-e96e-4f9f-bfa4-e82c975576a3", "method": "GET", "path": "/api/v1/discovery/discover", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.25, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/discovery/register
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/discovery/register - 422 (0.33ms)
INFO     brikk.requests:structured_logging.py:85 Request started: GET /api/v1/discovery/discover
INFO     brikk.requests:structured_logging.py:85 Request completed: GET /api/v1/discovery/discover - 422 (0.25ms)
____________________________ test_service_heartbeat ____________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'agent_id': '198512ee-6452-4b39-93af-0f05e7a9422b', 'organization_id': '850e8cb9-c972-4fa4-8d30-69947ed3190f'}

    def test_service_heartbeat(client: FlaskClient, auth_headers: dict):
        """Test sending a heartbeat to a service"""
        create_response = client.post("/api/v1/discovery/register", json={
            "service_name": "test-service",
            "service_url": "http://localhost:8080/service",
            "capabilities": []
        }, headers=auth_headers)
>       service_id = create_response.json["id"]
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_discovery_v1.py:91: KeyError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:44.687070+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:44.687165+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:44.753336+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/discovery/register", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 100}
{"timestamp": "2025-10-13T03:32:44.753783+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/discovery/register - 422 (0.28ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "80d03cab-710d-46b2-87c4-40c5c988a76f", "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.28, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/discovery/register
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/discovery/register - 422 (0.28ms)
___________________________ test_get_service_details ___________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'agent_id': '3089e215-afff-498c-a744-4369e4b13502', 'organization_id': 'a1a87c26-bafb-46d4-8833-a6965a85d448'}

    def test_get_service_details(client: FlaskClient, auth_headers: dict):
        """Test getting details of a specific service"""
        create_response = client.post("/api/v1/discovery/register", json={
            "service_name": "detailed-service",
            "service_url": "http://localhost:8080/detailed",
            "capabilities": ["test"]
        }, headers=auth_headers)
>       service_id = create_response.json["id"]
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_discovery_v1.py:127: KeyError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:44.864506+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:44.864601+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:44.931258+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/discovery/register", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 111}
{"timestamp": "2025-10-13T03:32:44.931738+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/discovery/register - 422 (0.32ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "9baee670-6a75-422d-b261-2802bbdd5730", "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.32, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/discovery/register
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/discovery/register - 422 (0.32ms)
_______________________________ test_get_balance _______________________________

client = <FlaskClient <Flask 'src.factory'>>

    def test_get_balance(client: FlaskClient):
        """Test retrieving the credit balance for an organization."""
        # This test requires a valid JWT token with an org_id
        # For now, we will mock the authentication
        headers = {"Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTY3OTg1NjAwMCwianRpIjoiZGV2LWp3dC1pZCIsIm5iZiI6MTY3OTg1NjAwMCwiZXhwIjoxNjc5ODU5NjAwLCJzdWIiOnsiZW1haWwiOiJ0ZXN0QGV4YW1wbGUuY29tIiwib3JnX2lkIjoiZGV2LW9yZy1pZCJ9fQ.mock_signature"}
        response = client.get("/api/v1/billing/balance", headers=headers)
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_economy_api_v1.py:33: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:44.950489+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:44.950581+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:45.010734+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/v1/billing/balance", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "GET", "path": "/api/v1/billing/balance", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:32:45.011223+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/v1/billing/balance - 404 (0.33ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "88bf5ce1-d1e3-4dc3-85c3-276ada2db3f1", "method": "GET", "path": "/api/v1/billing/balance", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.33, "event_type": "request_end", "status_code": 404, "content_length": 207}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: GET /api/v1/billing/balance
INFO     brikk.requests:structured_logging.py:85 Request completed: GET /api/v1/billing/balance - 404 (0.33ms)
_________________________ test_system_accounts_seeded __________________________

app = <Flask 'src.factory'>

    def test_system_accounts_seeded(app):
        with app.app_context():
            revenue_account = LedgerAccount.query.filter_by(name="platform_revenue").first()
            fees_account = LedgerAccount.query.filter_by(name="platform_fees").first()
            promotions_account = LedgerAccount.query.filter_by(name="promotions").first()
>           assert revenue_account is not None
E           assert None is not None

tests/test_economy_db_v1.py:43: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:45.103768+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:45.103862+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
______________ TestEnvelopeValidation.test_minimal_valid_envelope ______________

self = <tests.test_envelope_validation.TestEnvelopeValidation object at 0x7f69f2941490>

    def test_minimal_valid_envelope(self):
        """Test that minimal valid envelope passes validation."""
        envelope_data = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00.123Z",
            "sender": {"agent_id": "agent-001"},
            "recipient": {"agent_id": "agent-002"},
            "payload": {"action": "test"}
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='d3acea4d-cae9-45b6-855b-e7ebd7c486a7', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:34: ValidationError
_______________ TestEnvelopeValidation.test_full_valid_envelope ________________

self = <tests.test_envelope_validation.TestEnvelopeValidation object at 0x7f69f29417d0>

    def test_full_valid_envelope(self):
        """Test that envelope with all fields passes validation."""
        envelope_data = {
            "version": "1.0",
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "type": "command",
            "sender": {"agent_id": "agent-001", "org_id": "org-123"},
            "recipient": {"agent_id": "agent-002", "org_id": "org-456"},
            "payload": {"action": "execute", "params": {"key": "value"}},
            "ttl_ms": 60000,
            "reply_to": "msg-reply-123",
            "nonce": "nonce-456"
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='b02ac1aa-3831-4043-a155-da5c03463089', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:56: ValidationError
___________________ TestVersionValidation.test_valid_version ___________________

self = <tests.test_envelope_validation.TestVersionValidation object at 0x7f69f2941cd0>

    def test_valid_version(self):
        """Test that version 1.0 is accepted."""
        envelope_data = {
            "version": "1.0",
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "sender": {"agent_id": "agent-001"},
            "recipient": {"agent_id": "agent-002"},
            "payload": {"action": "test"}
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='010f8808-da88-4d2b-af32-4b3d64068c0a', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:78: ValidationError
___________________ TestMessageIdValidation.test_valid_uuid4 ___________________

self = <tests.test_envelope_validation.TestMessageIdValidation object at 0x7f69f2942ad0>

    def test_valid_uuid4(self):
        """Test that valid UUID4 is accepted (approximating UUIDv7)."""
        message_id = str(uuid.uuid4())
        envelope_data = {
            "message_id": message_id,
            "ts": "2023-10-02T14:30:00Z",
            "sender": {"agent_id": "agent-001"},
            "recipient": {"agent_id": "agent-002"},
            "payload": {"action": "test"}
        }
    
        # Note: Our current implementation accepts UUID4 as approximation
        # In production, this would need proper UUIDv7 validation
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='68c4ce48-8870-4a66-89c1-0b6a1b8a9d3f', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:115: ValidationError
____________ TestTimestampValidation.test_valid_rfc3339_timestamps _____________

self = <tests.test_envelope_validation.TestTimestampValidation object at 0x7f69f2943e90>

    def test_valid_rfc3339_timestamps(self):
        """Test that valid RFC3339 timestamps are accepted."""
        valid_timestamps = [
            "2023-10-02T14:30:00Z",
            "2023-10-02T14:30:00.123Z",
            "2023-10-02T14:30:00.123456Z",
            "2023-12-31T23:59:59Z"
        ]
    
        for ts in valid_timestamps:
            envelope_data = {
                "message_id": str(uuid.uuid4()),
                "ts": ts,
                "sender": {"agent_id": "agent-001"},
                "recipient": {"agent_id": "agent-002"},
                "payload": {"action": "test"}
            }
    
>           envelope = Envelope(**envelope_data)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^
E           pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E           message_id
E             Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='326a3e25-7095-4ff9-92a7-74bbf281e688', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:169: ValidationError
_____________________ TestTypeValidation.test_valid_types ______________________

self = <tests.test_envelope_validation.TestTypeValidation object at 0x7f69f295cd10>

    def test_valid_types(self):
        """Test that all valid message types are accepted."""
        valid_types = ["message", "event", "command", "result", "error"]
    
        for msg_type in valid_types:
            envelope_data = {
                "message_id": str(uuid.uuid4()),
                "ts": "2023-10-02T14:30:00Z",
                "type": msg_type,
                "sender": {"agent_id": "agent-001"},
                "recipient": {"agent_id": "agent-002"},
                "payload": {"action": "test"}
            }
    
>           envelope = Envelope(**envelope_data)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^
E           pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E           message_id
E             Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='61d2f7ba-d7ec-41f5-86d1-056a7c613361', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:216: ValidationError
__________ TestSenderRecipientValidation.test_valid_sender_recipient ___________

self = <tests.test_envelope_validation.TestSenderRecipientValidation object at 0x7f69f295db50>

    def test_valid_sender_recipient(self):
        """Test that valid sender/recipient are accepted."""
        envelope_data = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "sender": {"agent_id": "agent-001", "org_id": "org-123"},
            "recipient": {"agent_id": "agent-002", "org_id": "org-456"},
            "payload": {"action": "test"}
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='0b0222f4-7eb7-437e-817a-151a5280e75d', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:250: ValidationError
___________ TestSenderRecipientValidation.test_sender_without_org_id ___________

self = <tests.test_envelope_validation.TestSenderRecipientValidation object at 0x7f69f295e150>

    def test_sender_without_org_id(self):
        """Test that sender without org_id is accepted."""
        envelope_data = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "sender": {"agent_id": "agent-001"},
            "recipient": {"agent_id": "agent-002"},
            "payload": {"action": "test"}
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='bb71152b-e508-4016-a010-06c0c0aa85cf', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:266: ValidationError
___________________ TestTtlValidation.test_valid_ttl_values ____________________

self = <tests.test_envelope_validation.TestTtlValidation object at 0x7f69f295f590>

    def test_valid_ttl_values(self):
        """Test that valid TTL values are accepted."""
        valid_ttls = [1, 1000, 30000, 60000, 120000]
    
        for ttl in valid_ttls:
            envelope_data = {
                "message_id": str(uuid.uuid4()),
                "ts": "2023-10-02T14:30:00Z",
                "sender": {"agent_id": "agent-001"},
                "recipient": {"agent_id": "agent-002"},
                "payload": {"action": "test"},
                "ttl_ms": ttl
            }
    
>           envelope = Envelope(**envelope_data)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^
E           pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E           message_id
E             Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='6db68ee3-e3d9-4710-9b78-68acf5eada19', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:317: ValidationError
____________ TestExtraFieldsValidation.test_extra_fields_in_sender _____________

self = <tests.test_envelope_validation.TestExtraFieldsValidation object at 0x7f69f295f790>

    def test_extra_fields_in_sender(self):
        """Test that extra fields in sender are rejected."""
        envelope_data = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "sender": {
                "agent_id": "agent-001",
                "extra_field": "not_allowed"
            },
            "recipient": {"agent_id": "agent-002"},
            "payload": {"action": "test"}
        }
    
        with pytest.raises(ValidationError) as exc_info:
            Envelope(**envelope_data)
    
        errors = exc_info.value.errors()
>       assert any("extra_field" in str(error["loc"]) for error in errors)
E       assert False
E        +  where False = any(<generator object TestExtraFieldsValidation.test_extra_fields_in_sender.<locals>.<genexpr> at 0x7f69f083e200>)

tests/test_envelope_validation.py:378: AssertionError
______________ TestMinifyFunction.test_minify_removes_none_values ______________

self = <tests.test_envelope_validation.TestMinifyFunction object at 0x7f69f295ce90>

    def test_minify_removes_none_values(self):
        """Test that minify() removes None values."""
        envelope_data = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "sender": {"agent_id": "agent-001"},
            "recipient": {"agent_id": "agent-002"},
            "payload": {"action": "test"}
            # reply_to and nonce will be None by default
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='8751461e-5c79-428d-ad2d-99332a688c77', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:395: ValidationError
___________ TestMinifyFunction.test_minify_preserves_non_none_values ___________

self = <tests.test_envelope_validation.TestMinifyFunction object at 0x7f69f2960190>

    def test_minify_preserves_non_none_values(self):
        """Test that minify() preserves non-None values."""
        envelope_data = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "sender": {"agent_id": "agent-001", "org_id": "org-123"},
            "recipient": {"agent_id": "agent-002"},
            "payload": {"action": "test"},
            "reply_to": "msg-reply-123"
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='3e6b3721-8bcb-40bf-ba0c-b3c489c3ef75', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:421: ValidationError
_______________ TestMinifyFunction.test_minify_nested_structures _______________

self = <tests.test_envelope_validation.TestMinifyFunction object at 0x7f69f29604d0>

    def test_minify_nested_structures(self):
        """Test that minify() handles nested None values."""
        envelope_data = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "sender": {"agent_id": "agent-001"},
            "recipient": {"agent_id": "agent-002"},
            "payload": {
                "action": "test",
                "params": {
                    "key1": "value1",
                    "key2": None,
                    "key3": "value3"
                },
                "optional": None
            }
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='7417a92f-dd5a-418c-bc1d-393c6f8291f5', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:450: ValidationError
________ TestCreateSampleEnvelope.test_create_sample_envelope_defaults _________

self = <tests.test_envelope_validation.TestCreateSampleEnvelope object at 0x7f69f2960990>

    def test_create_sample_envelope_defaults(self):
        """Test that create_sample_envelope creates valid envelope with defaults."""
>       envelope = create_sample_envelope()
                   ^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_envelope_validation.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sender_agent_id = 'agent-001', recipient_agent_id = 'agent-002'
payload = {'action': 'test', 'data': 'sample'}

    def create_sample_envelope(
        sender_agent_id: str = "agent-001",
        recipient_agent_id: str = "agent-002",
        payload: Optional[Dict[str, Any]] = None
    ) -> Envelope:
        """
        Create a sample envelope for testing purposes.
    
        Args:
            sender_agent_id: Sender agent ID
            recipient_agent_id: Recipient agent ID
            payload: Optional payload dict
    
        Returns:
            Valid Envelope instance
        """
        if payload is None:
            payload = {"action": "test", "data": "sample"}
    
        # Generate UUIDv7 (approximation using uuid4 for now)
        message_id = str(uuid.uuid4())
    
        # Current UTC timestamp in RFC3339 format
        timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ')[:-3] + 'Z'
    
>       return Envelope(
            message_id=message_id,
            ts=timestamp,
            sender=Sender(agent_id=sender_agent_id),
            recipient=Recipient(agent_id=recipient_agent_id),
            payload=payload
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='bc8930b7-ff88-4cb0-a1de-86bde3c13308', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

src/schemas/envelope.py:225: ValidationError
______ TestCreateSampleEnvelope.test_create_sample_envelope_custom_params ______

self = <tests.test_envelope_validation.TestCreateSampleEnvelope object at 0x7f69f2960d10>

    def test_create_sample_envelope_custom_params(self):
        """Test that create_sample_envelope accepts custom parameters."""
        custom_payload = {"custom": "data"}
>       envelope = create_sample_envelope(
            sender_agent_id="custom-sender",
            recipient_agent_id="custom-recipient",
            payload=custom_payload
        )

tests/test_envelope_validation.py:478: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sender_agent_id = 'custom-sender', recipient_agent_id = 'custom-recipient'
payload = {'custom': 'data'}

    def create_sample_envelope(
        sender_agent_id: str = "agent-001",
        recipient_agent_id: str = "agent-002",
        payload: Optional[Dict[str, Any]] = None
    ) -> Envelope:
        """
        Create a sample envelope for testing purposes.
    
        Args:
            sender_agent_id: Sender agent ID
            recipient_agent_id: Recipient agent ID
            payload: Optional payload dict
    
        Returns:
            Valid Envelope instance
        """
        if payload is None:
            payload = {"action": "test", "data": "sample"}
    
        # Generate UUIDv7 (approximation using uuid4 for now)
        message_id = str(uuid.uuid4())
    
        # Current UTC timestamp in RFC3339 format
        timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ')[:-3] + 'Z'
    
>       return Envelope(
            message_id=message_id,
            ts=timestamp,
            sender=Sender(agent_id=sender_agent_id),
            recipient=Recipient(agent_id=recipient_agent_id),
            payload=payload
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='bff5454d-d52d-49ab-bef8-a0b20ef8673b', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

src/schemas/envelope.py:225: ValidationError
________ TestReadinessEndpoint.test_readiness_endpoint_redis_unhealthy _________

self = <tests.test_health.TestReadinessEndpoint object at 0x7f69f296e0d0>
mock_redis = <MagicMock name='redis' id='140092977937936'>
client = <FlaskClient <Flask 'src.factory'>>

    @patch('src.services.rate_limit.redis')
    def test_readiness_endpoint_redis_unhealthy(self, mock_redis, client):
        """Test readiness endpoint when Redis is unhealthy."""
        # Mock Redis connection failure
        mock_redis_instance = MagicMock()
        mock_redis_instance.ping.side_effect = Exception("Connection failed")
        mock_redis.return_value = mock_redis_instance
    
        response = client.get('/readyz')
>       assert response.status_code == 503
E       assert 200 == 503
E        +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_health.py:81: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:45.900613+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:45.900724+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_________ TestReadinessEndpoint.test_readiness_endpoint_redis_timeout __________

self = <tests.test_health.TestReadinessEndpoint object at 0x7f69f2941350>
mock_redis = <MagicMock name='redis' id='140092974856080'>
client = <FlaskClient <Flask 'src.factory'>>

    @patch('src.services.rate_limit.redis')
    def test_readiness_endpoint_redis_timeout(self, mock_redis, client):
        """Test readiness endpoint when Redis times out."""
        # Mock Redis timeout
        mock_redis_instance = MagicMock()
        mock_redis_instance.ping.side_effect = TimeoutError("Redis timeout")
        mock_redis.return_value = mock_redis_instance
    
        response = client.get('/readyz')
>       assert response.status_code == 503
E       assert 200 == 503
E        +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_health.py:99: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:45.991775+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:45.991886+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
________ TestHealthVsReadiness.test_health_vs_readiness_when_redis_down ________

self = <tests.test_health.TestHealthVsReadiness object at 0x7f69f296f090>
mock_redis = <MagicMock name='redis' id='140092980119824'>
client = <FlaskClient <Flask 'src.factory'>>

    @patch('src.services.rate_limit.redis')
    def test_health_vs_readiness_when_redis_down(self, mock_redis, client):
        """Test that health is always OK but readiness fails when Redis is down."""
        # Mock Redis failure
        mock_redis_instance = MagicMock()
        mock_redis_instance.ping.side_effect = Exception("Redis down")
        mock_redis.return_value = mock_redis_instance
    
        # Health should always be OK
        health_response = client.get('/healthz')
        assert health_response.status_code == 200
        health_data = health_response.get_json()
        assert health_data['status'] == 'healthy'
    
        # Readiness should fail
        readiness_response = client.get('/readyz')
>       assert readiness_response.status_code == 503
E       assert 200 == 503
E        +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_health.py:162: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:46.318573+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:46.318676+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
__ TestHealthEndpointErrorHandling.test_readiness_handles_redis_import_error ___

self = <tests.test_health.TestHealthEndpointErrorHandling object at 0x7f69f297acd0>
mock_redis = <MagicMock name='redis' id='140092984959440'>
client = <FlaskClient <Flask 'src.factory'>>

    @patch('src.services.rate_limit.redis')
    def test_readiness_handles_redis_import_error(self, mock_redis, client):
        """Test readiness endpoint handles Redis import errors gracefully."""
        # Mock Redis import failure
        mock_redis.side_effect = ImportError("Redis not available")
    
        response = client.get('/readyz')
>       assert response.status_code == 503
E       assert 200 == 503
E        +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_health.py:315: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:47.051296+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:47.051386+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_ TestHealthEndpointErrorHandling.test_readiness_handles_unexpected_redis_errors _

self = <tests.test_health.TestHealthEndpointErrorHandling object at 0x7f69f297b2d0>
mock_redis = <MagicMock name='redis' id='140092974374096'>
client = <FlaskClient <Flask 'src.factory'>>

    @patch('src.services.rate_limit.redis')
    def test_readiness_handles_unexpected_redis_errors(self, mock_redis, client):
        """Test readiness endpoint handles unexpected Redis errors."""
        # Mock unexpected Redis error
        mock_redis_instance = MagicMock()
        mock_redis_instance.ping.side_effect = RuntimeError("Unexpected error")
        mock_redis.return_value = mock_redis_instance
    
        response = client.get('/readyz')
>       assert response.status_code == 503
E       assert 200 == 503
E        +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_health.py:330: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:47.140002+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:47.140097+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_____________________________ test_create_webhook ______________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'organization_id': 'e906cfd6-3b67-4621-9815-22ec972b4e61'}

    def test_create_webhook(client: FlaskClient, auth_headers: dict):
        """Test creating a new webhook subscription"""
        webhook_data = {
            "url": "https://example.com/webhook",
            "secret": "supersecret",
            "events": ["agent.created", "coordination.completed"]
        }
    
        response = client.post("/api/v1/webhooks", json=webhook_data, headers=auth_headers)
>       assert response.status_code == 201
E       assert 422 == 201
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_integrations_v1.py:58: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:47.436417+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:47.436544+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:47.613469+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/webhooks", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 118}
{"timestamp": "2025-10-13T03:32:47.614013+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/webhooks - 422 (0.34ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "91dfd3d5-3c71-4399-ab6c-82c1ffd2bc4c", "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.34, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/webhooks
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/webhooks - 422 (0.34ms)
______________________________ test_get_webhooks _______________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'organization_id': '2225d2a9-64ef-4c2b-889d-e1459184b411'}

    def test_get_webhooks(client: FlaskClient, auth_headers: dict):
        """Test getting all webhooks for an organization"""
        # First, create a webhook
        client.post("/api/v1/webhooks", json={
            "url": "https://example.com/webhook",
            "secret": "supersecret",
            "events": ["agent.created"]
        }, headers=auth_headers)
    
        response = client.get("/api/v1/webhooks", headers=auth_headers)
>       assert response.status_code == 200
E       assert 422 == 200
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_integrations_v1.py:71: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:47.634780+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:47.634883+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:47.811915+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/webhooks", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 92}
{"timestamp": "2025-10-13T03:32:47.812523+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/webhooks - 422 (0.38ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "588b74e5-c0e4-4cb2-979d-830b5a402870", "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.38, "event_type": "request_end", "status_code": 422, "content_length": 30}
{"timestamp": "2025-10-13T03:32:47.813070+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/v1/webhooks", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "588b74e5-c0e4-4cb2-979d-830b5a402870", "method": "GET", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 1.0, "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:32:47.813499+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/v1/webhooks - 422 (0.29ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "6738d0b7-b331-4b53-bf11-33e95c12b8f6", "method": "GET", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.29, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/webhooks
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/webhooks - 422 (0.38ms)
INFO     brikk.requests:structured_logging.py:85 Request started: GET /api/v1/webhooks
INFO     brikk.requests:structured_logging.py:85 Request completed: GET /api/v1/webhooks - 422 (0.29ms)
_____________________________ test_update_webhook ______________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'organization_id': '882f87a5-c7d9-4d13-ba01-d6b5e7918fdf'}

    def test_update_webhook(client: FlaskClient, auth_headers: dict):
        """Test updating a webhook"""
        create_response = client.post("/api/v1/webhooks", json={
            "url": "https://example.com/webhook",
            "secret": "supersecret",
            "events": ["agent.created"]
        }, headers=auth_headers)
>       webhook_id = create_response.json["id"]
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_integrations_v1.py:81: KeyError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:47.833697+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:47.833797+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:48.015486+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/webhooks", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 92}
{"timestamp": "2025-10-13T03:32:48.016117+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/webhooks - 422 (0.37ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "cabc8abf-5cc0-4cf3-8e78-c90ba71e5340", "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.37, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/webhooks
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/webhooks - 422 (0.37ms)
_____________________________ test_delete_webhook ______________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'organization_id': 'cda2065f-35b9-41bb-bc05-c18bbf9d6aba'}

    def test_delete_webhook(client: FlaskClient, auth_headers: dict):
        """Test deleting a webhook"""
        create_response = client.post("/api/v1/webhooks", json={
            "url": "https://example.com/webhook",
            "secret": "supersecret",
            "events": ["agent.created"]
        }, headers=auth_headers)
>       webhook_id = create_response.json["id"]
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_integrations_v1.py:97: KeyError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:48.036382+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:48.036497+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:48.213222+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/webhooks", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 92}
{"timestamp": "2025-10-13T03:32:48.213805+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/webhooks - 422 (0.37ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "869f0628-625c-4a6a-82b3-2dc8f301168b", "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.37, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/webhooks
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/webhooks - 422 (0.37ms)
__________________________ test_webhook_event_trigger __________________________

mock_post = <MagicMock name='post' id='140092976910736'>
app = <Flask 'src.factory'>
auth_headers = {'Authorization': 'Bearer dummy_token', 'organization_id': 'd45e2c58-4cd8-442e-85c4-357d798cc761'}

    @patch("requests.post")
    def test_webhook_event_trigger(mock_post, app: Flask, auth_headers: dict):
        """Test triggering a webhook event"""
        mock_post.return_value.status_code = 200
    
        with app.app_context():
            db_session = db.session
            webhook_service = WebhookService(db_session)
    
            # Create a webhook
            webhook = webhook_service.create_webhook(
                organization_id=auth_headers["organization_id"],
                url="https://example.com/webhook",
                secret="secret",
                events=["test.event"]
            )
    
            # Trigger an event
            webhook_service.trigger_event(
                event_type="test.event",
                payload_data={"key": "value"},
                organization_id=auth_headers["organization_id"]
            )
    
            # Verify that requests.post was called
            mock_post.assert_called_once()
            call_args = mock_post.call_args
>           assert call_args.kwargs["url"] == webhook.url
                   ^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'url'

tests/test_integrations_v1.py:132: KeyError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:48.234173+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:48.234274+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:48.412638+00:00", "level": "INFO", "logger": "brikk.webhooks", "message": "Created webhook 1 for organization d45e2c58-4cd8-442e-85c4-357d798cc761", "module": "structured_logging", "function": "_log_with_context", "line": 85}
{"timestamp": "2025-10-13T03:32:48.420635+00:00", "level": "ERROR", "logger": "brikk.webhooks", "message": "Failed to send webhook event 1: (sqlite3.ProgrammingError) Error binding parameter 3: type 'MagicMock' is not supported\n[SQL: UPDATE webhook_events SET status=?, response_status_code=?, response_body=?, updated_at=CURRENT_TIMESTAMP WHERE webhook_events.id = ?]\n[parameters: ('success', 200, <MagicMock name='post().text' id='140092976954896'>, 1)]\n(Background on this error at: https://sqlalche.me/e/20/f405)", "module": "structured_logging", "function": "_log_with_context", "line": 85}
{"timestamp": "2025-10-13T03:32:48.421378+00:00", "level": "ERROR", "logger": "brikk.webhooks", "message": "Failed to create webhook event for webhook 1: This Session's transaction has been rolled back due to a previous exception during flush. To begin a new transaction with this Session, first issue Session.rollback(). Original exception was: (sqlite3.ProgrammingError) Error binding parameter 3: type 'MagicMock' is not supported\n[SQL: UPDATE webhook_events SET status=?, response_status_code=?, response_body=?, updated_at=CURRENT_TIMESTAMP WHERE webhook_events.id = ?]\n[parameters: ('success', 200, <MagicMock name='post().text' id='140092976954896'>, 1)]\n(Background on this error at: https://sqlalche.me/e/20/f405) (Background on this error at: https://sqlalche.me/e/20/7s2a)", "module": "structured_logging", "function": "_log_with_context", "line": 85}
------------------------------ Captured log call -------------------------------
INFO     brikk.webhooks:structured_logging.py:85 Created webhook 1 for organization d45e2c58-4cd8-442e-85c4-357d798cc761
ERROR    brikk.webhooks:structured_logging.py:85 Failed to send webhook event 1: (sqlite3.ProgrammingError) Error binding parameter 3: type 'MagicMock' is not supported
[SQL: UPDATE webhook_events SET status=?, response_status_code=?, response_body=?, updated_at=CURRENT_TIMESTAMP WHERE webhook_events.id = ?]
[parameters: ('success', 200, <MagicMock name='post().text' id='140092976954896'>, 1)]
(Background on this error at: https://sqlalche.me/e/20/f405)
ERROR    brikk.webhooks:structured_logging.py:85 Failed to create webhook event for webhook 1: This Session's transaction has been rolled back due to a previous exception during flush. To begin a new transaction with this Session, first issue Session.rollback(). Original exception was: (sqlite3.ProgrammingError) Error binding parameter 3: type 'MagicMock' is not supported
[SQL: UPDATE webhook_events SET status=?, response_status_code=?, response_body=?, updated_at=CURRENT_TIMESTAMP WHERE webhook_events.id = ?]
[parameters: ('success', 200, <MagicMock name='post().text' id='140092976954896'>, 1)]
(Background on this error at: https://sqlalche.me/e/20/f405) (Background on this error at: https://sqlalche.me/e/20/7s2a)
__________ TestRequestContextMiddleware.test_auth_context_integration __________

self = <tests.test_logging_context.TestRequestContextMiddleware object at 0x7f69f29a3ad0>
app = <Flask 'tests.test_logging_context'>

    def test_auth_context_integration(self, app):
        """Test that auth context is included in request context."""
        init_request_context(app)
    
        @app.route('/test')
        def test_route():
            # Set auth context
            set_auth_context({
                'org_id': 'test-org',
                'key_id': 'test-key',
                'agent_id': 'test-agent'
            })
    
            context = get_request_context()
            return context
    
        client = app.test_client()
        response = client.get('/test')
        assert response.status_code == 200
    
        context = response.get_json()
        assert 'organization_id' in context
>       assert 'api_key_id' in context
E       AssertionError: assert 'api_key_id' in {'duration_ms': 0.02, 'method': 'GET', 'organization_id': {'agent_id': 'test-agent', 'key_id': 'test-key', 'org_id': 'test-org'}, 'path': '/test', ...}

tests/test_logging_context.py:175: AssertionError
______________ TestStructuredFormatter.test_exception_formatting _______________

self = <tests.test_logging_context.TestStructuredFormatter object at 0x7f69f29ace50>

    def test_exception_formatting(self):
        """Test exception formatting in JSON logs."""
        formatter = StructuredFormatter(json_enabled=True)
    
        try:
            raise ValueError("Test exception")
        except ValueError:
            record = logging.LogRecord(
                name='test.logger',
                level=logging.ERROR,
                pathname='test.py',
                lineno=42,
                msg='Error occurred',
                args=(),
                exc_info=True
            )
    
>       formatted = formatter.format(record)
                    ^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_logging_context.py:294: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/services/structured_logging.py:60: in format
    log_entry['exception'] = self.formatException(record.exc_info)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.services.structured_logging.StructuredFormatter object at 0x7f69f01ce490>
ei = True

    def formatException(self, ei):
        """
        Format and return the specified exception information as a string.
    
        This default implementation just uses
        traceback.print_exception()
        """
        sio = io.StringIO()
>       tb = ei[2]
             ^^^^^
E       TypeError: 'bool' object is not subscriptable

/usr/lib/python3.11/logging/__init__.py:641: TypeError
________ TestRateLimitIntegration.test_coordination_rate_limit_disabled ________

self = <tests.test_rate_limit.TestRateLimitIntegration object at 0x7f69f255ff90>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    def test_coordination_rate_limit_disabled(self, client, valid_envelope):
        """Test coordination endpoint with rate limiting disabled."""
        with patch.dict(os.environ, {
            'BRIKK_RLIMIT_ENABLED': 'false',
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
>           assert response.status_code == 202
E           assert 422 == 202
E            +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_rate_limit.py:284: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:48.557280+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:48.557365+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:48.618194+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:32:48.619202+00:00", "level": "ERROR", "logger": "src.services.rate_limit", "message": "Failed to connect to Redis: Error 111 connecting to localhost:6379. Connection refused.", "module": "rate_limit", "function": "_create_redis_client", "line": 94, "request_id": "40a782b3-67e6-4070-901d-47a3bdfe5d5a", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.85}
{"timestamp": "2025-10-13T03:32:48.619735+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (1.31ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "40a782b3-67e6-4070-901d-47a3bdfe5d5a", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 1.31, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
ERROR    src.services.rate_limit:rate_limit.py:94 Failed to connect to Redis: Error 111 connecting to localhost:6379. Connection refused.
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (1.31ms)
________ TestRateLimitIntegration.test_coordination_rate_limit_allowed _________

self = <tests.test_rate_limit.TestRateLimitIntegration object at 0x7f69f25643d0>
mock_redis_factory = <MagicMock name='_create_redis_client' id='140092982675728'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    @patch('src.services.rate_limit.RateLimitService._create_redis_client')
    def test_coordination_rate_limit_allowed(self, mock_redis_factory, client, valid_envelope):
        """Test coordination endpoint with rate limiting enabled and request allowed."""
        # Mock Redis client
        mock_redis = MagicMock()
        mock_redis.ping.return_value = True
        mock_pipeline = MagicMock()
        mock_pipeline.execute.return_value = [0, 1, 5, True]  # 5 requests in window
        mock_redis.pipeline.return_value = mock_pipeline
        mock_redis_factory.return_value = mock_redis
    
        with patch.dict(os.environ, {
            'BRIKK_RLIMIT_ENABLED': 'true',
            'BRIKK_RLIMIT_PER_MIN': '60',
            'BRIKK_RLIMIT_BURST': '20',
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
>           assert response.status_code == 202
E           assert 422 == 202
E            +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_rate_limit.py:315: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:48.628046+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:48.628131+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:48.653861+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:32:48.656119+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (2.04ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "987e3991-470d-4aa7-a86e-71ecea63edbd", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 2.04, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (2.04ms)
________ TestRateLimitIntegration.test_coordination_rate_limit_exceeded ________

self = <tests.test_rate_limit.TestRateLimitIntegration object at 0x7f69f2564810>
mock_redis_factory = <MagicMock name='_create_redis_client' id='140092972425872'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    @patch('src.services.rate_limit.RateLimitService._create_redis_client')
    def test_coordination_rate_limit_exceeded(self, mock_redis_factory, client, valid_envelope):
        """Test coordination endpoint with rate limit exceeded."""
        # Mock Redis client to return count above limit
        mock_redis = MagicMock()
        mock_redis.ping.return_value = True
        mock_pipeline = MagicMock()
        mock_pipeline.execute.return_value = [0, 1, 85, True]  # 85 requests (above 80 limit)
        mock_redis.pipeline.return_value = mock_pipeline
        mock_redis.zrange.return_value = [('1640995140.123', 1640995140.123)]
        mock_redis_factory.return_value = mock_redis
    
        with patch.dict(os.environ, {
            'BRIKK_RLIMIT_ENABLED': 'true',
            'BRIKK_RLIMIT_PER_MIN': '60',
            'BRIKK_RLIMIT_BURST': '20',
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
>           assert response.status_code == 429
E           assert 500 == 429
E            +  where 500 = <WrapperTestResponse streamed [500 INTERNAL SERVER ERROR]>.status_code

tests/test_rate_limit.py:350: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:48.665030+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:48.665115+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stdout call -----------------------------
Coordination endpoint error: 'MetricsService' object has no attribute 'record_rate_limit_hit'
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:48.689896+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:32:48.691754+00:00", "level": "WARNING", "logger": "brikk.rate_limit", "message": "Rate limit exceeded for scope: None", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "9b2337bc-e5cd-4337-a4f4-4041d758f9a3", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 1.71, "event_type": "rate_limit", "scope": null, "limit_exceeded": true, "limit": 80, "remaining": 0}
Traceback (most recent call last):
  File "/home/ubuntu/brikk-infrastructure/src/routes/coordination.py", line 199, in coordination_endpoint
    get_metrics_service().record_rate_limit_hit(scope)
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'MetricsService' object has no attribute 'record_rate_limit_hit'
{"timestamp": "2025-10-13T03:32:48.692255+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 500 (2.15ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "a51324da-ed90-4dad-9d88-887e387f523d", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 2.15, "event_type": "request_end", "status_code": 500, "content_length": 119}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
WARNING  brikk.rate_limit:structured_logging.py:85 Rate limit exceeded for scope: None
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 500 (2.15ms)
_____ TestRateLimitIntegration.test_coordination_rate_limit_burst_behavior _____

self = <tests.test_rate_limit.TestRateLimitIntegration object at 0x7f69f2564e90>
mock_redis_factory = <MagicMock name='_create_redis_client' id='140092972643664'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    @patch('src.services.rate_limit.RateLimitService._create_redis_client')
    def test_coordination_rate_limit_burst_behavior(self, mock_redis_factory, client, valid_envelope):
        """Test burst capacity behavior."""
        mock_redis = MagicMock()
        mock_redis.ping.return_value = True
        mock_redis_factory.return_value = mock_redis
    
        with patch.dict(os.environ, {
            'BRIKK_RLIMIT_ENABLED': 'true',
            'BRIKK_RLIMIT_PER_MIN': '10',  # Low base limit
            'BRIKK_RLIMIT_BURST': '5',     # Small burst
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            # Test requests within burst capacity (total limit = 15)
            for count in [5, 10, 14]:  # Within limit
                mock_pipeline = MagicMock()
                mock_pipeline.execute.return_value = [0, 1, count, True]
                mock_redis.pipeline.return_value = mock_pipeline
    
                response = client.post(
                    '/api/v1/coordination',
                    data=json.dumps(valid_envelope),
                    headers={'Content-Type': 'application/json'}
                )
    
>               assert response.status_code == 202
E               assert 422 == 202
E                +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_rate_limit.py:392: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:48.820538+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:48.820655+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:48.846175+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:32:48.848539+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (2.14ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "e9b2116a-ee28-46f6-a4d9-9363cd85fbc7", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 2.14, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (2.14ms)
____ TestRateLimitIntegration.test_coordination_rate_limit_scope_switching _____

self = <tests.test_rate_limit.TestRateLimitIntegration object at 0x7f69f25654d0>
mock_redis_factory = <MagicMock name='_create_redis_client' id='140092976573776'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    @patch('src.services.rate_limit.RateLimitService._create_redis_client')
    def test_coordination_rate_limit_scope_switching(self, mock_redis_factory, client, valid_envelope):
        """Test rate limiting with different scoping configurations."""
        mock_redis = MagicMock()
        mock_redis.ping.return_value = True
        mock_pipeline = MagicMock()
        mock_pipeline.execute.return_value = [0, 1, 5, True]
        mock_redis.pipeline.return_value = mock_pipeline
        mock_redis_factory.return_value = mock_redis
    
        # Test organization scoping
        with patch.dict(os.environ, {
            'BRIKK_RLIMIT_ENABLED': 'true',
            'BRIKK_RLIMIT_SCOPE': 'org',
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
>           assert response.status_code == 202
E           assert 422 == 202
E            +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_rate_limit.py:432: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:48.857352+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:48.857437+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:48.881987+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:32:48.884559+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (2.36ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "7ce61a58-8784-4f39-ba0d-4f0d51325e94", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 2.36, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (2.36ms)
_____ TestRateLimitIntegration.test_coordination_rate_limit_redis_failure ______

self = <tests.test_rate_limit.TestRateLimitIntegration object at 0x7f69f2565b10>
mock_redis_factory = <MagicMock name='_create_redis_client' id='140092974761232'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    @patch('src.services.rate_limit.RateLimitService._create_redis_client')
    def test_coordination_rate_limit_redis_failure(self, mock_redis_factory, client, valid_envelope):
        """Test graceful degradation when Redis fails."""
        # Mock Redis to raise exception
        mock_redis = MagicMock()
        mock_redis.ping.return_value = True
        mock_redis.pipeline.side_effect = Exception("Redis connection failed")
        mock_redis_factory.return_value = mock_redis
    
        with patch.dict(os.environ, {
            'BRIKK_RLIMIT_ENABLED': 'true',
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
            # Should succeed despite Redis failure (graceful degradation)
>           assert response.status_code == 202
E           assert 422 == 202
E            +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_rate_limit.py:483: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:48.892242+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:48.892327+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:48.916790+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:32:48.917233+00:00", "level": "ERROR", "logger": "src.services.rate_limit", "message": "Rate limit check failed for rlimit:anonymous: Redis connection failed", "module": "rate_limit", "function": "check_rate_limit", "line": 190, "request_id": "5cfddcda-bc80-4e6a-854e-2671b8cb72da", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.29}
{"timestamp": "2025-10-13T03:32:48.917591+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (0.6ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "5cfddcda-bc80-4e6a-854e-2671b8cb72da", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.6, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
ERROR    src.services.rate_limit:rate_limit.py:190 Rate limit check failed for rlimit:anonymous: Redis connection failed
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (0.6ms)
____ TestRateLimitIntegration.test_coordination_rate_limit_with_idempotency ____

self = <tests.test_rate_limit.TestRateLimitIntegration object at 0x7f69f2566210>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    def test_coordination_rate_limit_with_idempotency(self, client, valid_envelope):
        """Test rate limiting works alongside idempotency."""
        with patch.dict(os.environ, {
            'BRIKK_RLIMIT_ENABLED': 'true',
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'true'
        }):
            # Mock rate limiter to allow request
            with patch('src.services.rate_limit.get_rate_limiter') as mock_get_limiter:
                mock_limiter = MagicMock()
                mock_limiter.check_rate_limit.return_value = RateLimitResult(
                    allowed=True, limit=80, remaining=75, reset_time=1640995200
                )
                mock_get_limiter.return_value = mock_limiter
    
                response = client.post(
                    '/api/v1/coordination',
                    data=json.dumps(valid_envelope),
                    headers={'Content-Type': 'application/json'}
                )
    
>               assert response.status_code == 202
E               assert 422 == 202
E                +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_rate_limit.py:511: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:48.925204+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:48.925295+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stdout call -----------------------------
Idempotency check error: 'NoneType' object has no attribute 'get'
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:48.949754+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:32:48.950804+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (0.85ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "bd74a624-39bd-48bf-9673-deba4a33013d", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.85, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (0.85ms)
__________ TestBodySizeValidation.test_invalid_content_length_header ___________

self = <tests.test_request_guards.TestBodySizeValidation object at 0x7f69f257c1d0>
client = <FlaskClient <Flask 'tests.test_request_guards'>>

    def test_invalid_content_length_header(self, client):
        """Test that invalid Content-Length header is rejected with 400."""
        response = client.post(
            '/test',
            headers={
                'Content-Type': 'application/json',
                'Content-Length': 'invalid',
                'X-Brikk-Key': 'test-key',
                'X-Brikk-Timestamp': '1234567890',
                'X-Brikk-Signature': 'test-signature'
            },
            json={"test": "data"}
        )
>       assert response.status_code == 400
E       assert 200 == 400
E        +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_request_guards.py:201: AssertionError
______________________________ test_ping_endpoint ______________________________

client = <FlaskClient <Flask 'src.factory'>>

    def test_ping_endpoint(client):
        """Test that the ping endpoint returns a valid response."""
        response = client.get('/api/inbound/_ping')
        # Accept 200 OK or 302 redirect as valid responses
>       assert response.status_code in [200, 302]
E       assert 404 in [200, 302]
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_smoke.py:32: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:49.030479+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:49.030570+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:49.054914+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/inbound/_ping", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "GET", "path": "/api/inbound/_ping", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:32:49.055395+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/inbound/_ping - 404 (0.26ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "67f08bc5-8d67-45a1-8161-7f74f6e72971", "method": "GET", "path": "/api/inbound/_ping", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.26, "event_type": "request_end", "status_code": 404, "content_length": 207}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: GET /api/inbound/_ping
INFO     brikk.requests:structured_logging.py:85 Request completed: GET /api/inbound/_ping - 404 (0.26ms)
___________________________ test_basic_routes_exist ____________________________

client = <FlaskClient <Flask 'src.factory'>>

    def test_basic_routes_exist(client):
        """Test that basic application routes are accessible (don't return 404)."""
        # Test ping endpoint specifically
        response = client.get('/api/inbound/_ping')
>       assert response.status_code != 404
E       assert 404 != 404
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_smoke.py:53: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:32:49.084233+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:32:49.084318+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:32:49.109500+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/inbound/_ping", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "GET", "path": "/api/inbound/_ping", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:32:49.109979+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/inbound/_ping - 404 (0.26ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "a06c0ed0-c75f-413d-8966-616ddfd841d6", "method": "GET", "path": "/api/inbound/_ping", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.26, "event_type": "request_end", "status_code": 404, "content_length": 207}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: GET /api/inbound/_ping
INFO     brikk.requests:structured_logging.py:85 Request completed: GET /api/inbound/_ping - 404 (0.26ms)
=============================== warnings summary ===============================
tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_feature_disabled
  /home/ubuntu/brikk-infrastructure/src/schemas/auth.py:19: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    @validator('slug')

tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_feature_disabled
  /home/ubuntu/brikk-infrastructure/src/schemas/auth.py:26: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    @validator('contact_email')

tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_feature_disabled
  /home/ubuntu/brikk-infrastructure/src/schemas/auth.py:43: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    @validator('agent_id')

tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_feature_disabled
  /home/ubuntu/brikk-infrastructure/src/schemas/auth.py:61: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    @validator('scopes')

tests/test_integrations_v1.py::test_webhook_event_trigger
  /home/ubuntu/brikk-infrastructure/src/services/webhook_service.py:156: SAWarning: Session's state has been changed on a non-active transaction - this state will be discarded.
    self.db.rollback()

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/auth/test_api_key_rotation.py::TestApiKeyRotation::test_api_key_creation
FAILED tests/auth/test_api_key_rotation.py::TestApiKeyRotation::test_api_key_rotation
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_feature_disabled
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_missing_headers
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_invalid_timestamp
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_invalid_api_key
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_check_idempotency_feature_disabled
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_check_idempotency_no_auth
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_check_idempotency_success
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_check_idempotency_replay
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_set_auth_context
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_log_auth_result_success
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_log_auth_result_failure
FAILED tests/auth/test_idempotency.py::TestIdempotencyService::test_process_request_idempotency_with_custom_key
FAILED tests/test_basic.py::test_inbound_ping_endpoint - assert 404 == 200
FAILED tests/test_basic.py::test_database_url_normalization - NameError: name...
FAILED tests/test_basic.py::test_blueprint_registration - AssertionError: Blu...
FAILED tests/test_billing_portal_stripe13.py::test_billing_portal_request_validation
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_flags_off
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_valid_hmac
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_missing_headers
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_invalid_api_key
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_invalid_signature
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_timestamp_drift
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_idempotent_replay
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_idempotency_conflict
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_health_endpoint
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_security_headers_present
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_with_custom_idempotency_key
FAILED tests/test_coordination_stub.py::TestCoordinationEndpoint::test_valid_request_returns_202
FAILED tests/test_coordination_stub.py::TestCoordinationEndpoint::test_minimal_valid_envelope
FAILED tests/test_coordination_stub.py::TestCoordinationEndpoint::test_security_headers_present
FAILED tests/test_coordination_stub.py::TestRequestGuardsIntegration::test_missing_content_type_returns_415
FAILED tests/test_coordination_stub.py::TestRequestGuardsIntegration::test_missing_brikk_headers_returns_400
FAILED tests/test_coordination_stub.py::TestRequestGuardsIntegration::test_oversized_body_returns_413
FAILED tests/test_coordination_stub.py::TestEnvelopeValidationIntegration::test_missing_required_fields_returns_422
FAILED tests/test_coordination_stub.py::TestErrorHandling::test_error_responses_have_security_headers
FAILED tests/test_coordination_stub.py::TestHealthCheckEndpoint::test_health_check_returns_200
FAILED tests/test_coordination_stub.py::TestMessageTypes::test_all_message_types_accepted
FAILED tests/test_coordination_v1.py::test_coordination_v1_invalid_signature
FAILED tests/test_coordination_v1.py::test_coordination_v1_idempotency - asse...
FAILED tests/test_discovery_v1.py::test_register_service - assert 422 == 201
FAILED tests/test_discovery_v1.py::test_discover_services - assert 422 == 200
FAILED tests/test_discovery_v1.py::test_service_heartbeat - KeyError: 'id'
FAILED tests/test_discovery_v1.py::test_get_service_details - KeyError: 'id'
FAILED tests/test_economy_api_v1.py::test_get_balance - assert 404 == 200
FAILED tests/test_economy_db_v1.py::test_system_accounts_seeded - assert None...
FAILED tests/test_envelope_validation.py::TestEnvelopeValidation::test_minimal_valid_envelope
FAILED tests/test_envelope_validation.py::TestEnvelopeValidation::test_full_valid_envelope
FAILED tests/test_envelope_validation.py::TestVersionValidation::test_valid_version
FAILED tests/test_envelope_validation.py::TestMessageIdValidation::test_valid_uuid4
FAILED tests/test_envelope_validation.py::TestTimestampValidation::test_valid_rfc3339_timestamps
FAILED tests/test_envelope_validation.py::TestTypeValidation::test_valid_types
FAILED tests/test_envelope_validation.py::TestSenderRecipientValidation::test_valid_sender_recipient
FAILED tests/test_envelope_validation.py::TestSenderRecipientValidation::test_sender_without_org_id
FAILED tests/test_envelope_validation.py::TestTtlValidation::test_valid_ttl_values
FAILED tests/test_envelope_validation.py::TestExtraFieldsValidation::test_extra_fields_in_sender
FAILED tests/test_envelope_validation.py::TestMinifyFunction::test_minify_removes_none_values
FAILED tests/test_envelope_validation.py::TestMinifyFunction::test_minify_preserves_non_none_values
FAILED tests/test_envelope_validation.py::TestMinifyFunction::test_minify_nested_structures
FAILED tests/test_envelope_validation.py::TestCreateSampleEnvelope::test_create_sample_envelope_defaults
FAILED tests/test_envelope_validation.py::TestCreateSampleEnvelope::test_create_sample_envelope_custom_params
FAILED tests/test_health.py::TestReadinessEndpoint::test_readiness_endpoint_redis_unhealthy
FAILED tests/test_health.py::TestReadinessEndpoint::test_readiness_endpoint_redis_timeout
FAILED tests/test_health.py::TestHealthVsReadiness::test_health_vs_readiness_when_redis_down
FAILED tests/test_health.py::TestHealthEndpointErrorHandling::test_readiness_handles_redis_import_error
FAILED tests/test_health.py::TestHealthEndpointErrorHandling::test_readiness_handles_unexpected_redis_errors
FAILED tests/test_integrations_v1.py::test_create_webhook - assert 422 == 201
FAILED tests/test_integrations_v1.py::test_get_webhooks - assert 422 == 200
FAILED tests/test_integrations_v1.py::test_update_webhook - KeyError: 'id'
FAILED tests/test_integrations_v1.py::test_delete_webhook - KeyError: 'id'
FAILED tests/test_integrations_v1.py::test_webhook_event_trigger - KeyError: ...
FAILED tests/test_logging_context.py::TestRequestContextMiddleware::test_auth_context_integration
FAILED tests/test_logging_context.py::TestStructuredFormatter::test_exception_formatting
FAILED tests/test_rate_limit.py::TestRateLimitIntegration::test_coordination_rate_limit_disabled
FAILED tests/test_rate_limit.py::TestRateLimitIntegration::test_coordination_rate_limit_allowed
FAILED tests/test_rate_limit.py::TestRateLimitIntegration::test_coordination_rate_limit_exceeded
FAILED tests/test_rate_limit.py::TestRateLimitIntegration::test_coordination_rate_limit_burst_behavior
FAILED tests/test_rate_limit.py::TestRateLimitIntegration::test_coordination_rate_limit_scope_switching
FAILED tests/test_rate_limit.py::TestRateLimitIntegration::test_coordination_rate_limit_redis_failure
FAILED tests/test_rate_limit.py::TestRateLimitIntegration::test_coordination_rate_limit_with_idempotency
FAILED tests/test_request_guards.py::TestBodySizeValidation::test_invalid_content_length_header
FAILED tests/test_smoke.py::test_ping_endpoint - assert 404 in [200, 302]
FAILED tests/test_smoke.py::test_basic_routes_exist - assert 404 != 404
=========== 84 failed, 185 passed, 20 skipped, 5 warnings in 11.17s ============
