============================= test session starts ==============================
platform linux -- Python 3.11.0rc1, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/ubuntu/brikk-infrastructure
plugins: anyio-4.10.0, cov-7.0.0
collected 287 items

tests/auth/test_api_key_rotation.py FF                                   [  0%]
tests/auth/test_hmac_auth.py ..........................FFFFFFFFFFF       [ 13%]
tests/auth/test_idempotency.py .........F.                               [ 17%]
tests/examples/test_python_agent.py ...                                  [ 18%]
tests/smoke/test_app_startup.py sssssssss...                             [ 22%]
tests/smoke/test_coordination_api.py sssssssssss                         [ 26%]
tests/test_basic.py ..FF.....                                            [ 29%]
tests/test_billing_portal.py ..........                                  [ 33%]
tests/test_billing_portal_stripe13.py .F.                                [ 34%]
tests/test_coordination_auth.py FFFFFFFF..FFF                            [ 38%]
tests/test_coordination_stub.py FFFFFF.F......FF..F                      [ 45%]
tests/test_coordination_v1.py .FF                                        [ 46%]
tests/test_discovery_v1.py FFF.F                                         [ 48%]
tests/test_economy_api_v1.py F                                           [ 48%]
tests/test_economy_db_v1.py .F.                                          [ 49%]
tests/test_envelope_uuid_validation.py .......                           [ 51%]
tests/test_envelope_validation.py FFF.F..F.F.FF..F..FFFFFF               [ 60%]
tests/test_health.py FFFFFFFFFFFFFFFFFFFFFF                              [ 67%]
tests/test_integrations_v1.py FFFFF                                      [ 69%]
tests/test_logging_context.py .....F...F...........                      [ 77%]
tests/test_metrics.py .....                                              [ 78%]
tests/test_performance_v1.py ....                                        [ 80%]
tests/test_rate_limit.py .............FFFFFFF..                          [ 87%]
tests/test_request_guards.py ........F.........                          [ 94%]
tests/test_smoke.py .F.F                                                 [ 95%]
tests/test_stripe_13_compatibility.py .........                          [ 98%]
tests/test_workflows_v1.py ....                                          [100%]

=================================== FAILURES ===================================
___________________ TestApiKeyRotation.test_api_key_creation ___________________

self = <cryptography.fernet.Fernet object at 0x7fcff022f650>
key = b'test_key_32_bytes_long_for_fernet', backend = None

    def __init__(
        self,
        key: bytes | str,
        backend: typing.Any = None,
    ) -> None:
        try:
>           key = base64.urlsafe_b64decode(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/dist-packages/cryptography/fernet.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/base64.py:134: in urlsafe_b64decode
    return b64decode(s)
           ^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = b'test/key/32/bytes/long/for/fernet', altchars = None, validate = False

    def b64decode(s, altchars=None, validate=False):
        """Decode the Base64 encoded bytes-like object or ASCII string s.
    
        Optional altchars must be a bytes-like object or ASCII string of length 2
        which specifies the alternative alphabet used instead of the '+' and '/'
        characters.
    
        The result is returned as a bytes object.  A binascii.Error is raised if
        s is incorrectly padded.
    
        If validate is False (the default), characters that are neither in the
        normal base-64 alphabet nor the alternative alphabet are discarded prior
        to the padding check.  If validate is True, these non-alphabet characters
        in the input result in a binascii.Error.
        For more information about the strict base64 check, see:
    
        https://docs.python.org/3.11/library/binascii.html#binascii.a2b_base64
        """
        s = _bytes_from_decode_data(s)
        if altchars is not None:
            altchars = _bytes_from_decode_data(altchars)
            assert len(altchars) == 2, repr(altchars)
            s = s.translate(bytes.maketrans(altchars, b'+/'))
>       return binascii.a2b_base64(s, strict_mode=validate)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       binascii.Error: Invalid base64-encoded string: number of data characters (33) cannot be 1 more than a multiple of 4

/usr/lib/python3.11/base64.py:88: Error

The above exception was the direct cause of the following exception:

self = <tests.auth.test_api_key_rotation.TestApiKeyRotation object at 0x7fcff28d34d0>
app = <Flask 'tests.auth.test_api_key_rotation'>
test_org = <Organization Test Organization (test-org)>
test_agent = <Agent 1d1ec52f-e349-4d17-9e02-8feda4fa896c 'Test Agent for Rotation'>

    def test_api_key_creation(self, app, test_org, test_agent):
        """Test API key creation with proper encryption."""
        with app.app_context():
            with patch.dict(
                os.environ, {"BRIKK_ENCRYPTION_KEY": "test_key_32_bytes_long_for_fernet"}
            ):
>               api_key, secret = ApiKey.create_api_key(
                    organization_id=test_org.id,
                    name="Test Key for Rotation",
                    agent_id=test_agent.id,
                )

tests/auth/test_api_key_rotation.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/models/api_key.py:79: in create_api_key
    fernet = get_fernet()
             ^^^^^^^^^^^^
src/models/api_key.py:23: in get_fernet
    return Fernet(encryption_key.encode())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cryptography.fernet.Fernet object at 0x7fcff022f650>
key = b'test_key_32_bytes_long_for_fernet', backend = None

    def __init__(
        self,
        key: bytes | str,
        backend: typing.Any = None,
    ) -> None:
        try:
            key = base64.urlsafe_b64decode(key)
        except binascii.Error as exc:
>           raise ValueError(
                "Fernet key must be 32 url-safe base64-encoded bytes."
            ) from exc
E           ValueError: Fernet key must be 32 url-safe base64-encoded bytes.

/usr/local/lib/python3.11/dist-packages/cryptography/fernet.py:37: ValueError
___________________ TestApiKeyRotation.test_api_key_rotation ___________________

self = <cryptography.fernet.Fernet object at 0x7fcff0170290>
key = b'test_key_32_bytes_long_for_fernet', backend = None

    def __init__(
        self,
        key: bytes | str,
        backend: typing.Any = None,
    ) -> None:
        try:
>           key = base64.urlsafe_b64decode(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/dist-packages/cryptography/fernet.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/base64.py:134: in urlsafe_b64decode
    return b64decode(s)
           ^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = b'test/key/32/bytes/long/for/fernet', altchars = None, validate = False

    def b64decode(s, altchars=None, validate=False):
        """Decode the Base64 encoded bytes-like object or ASCII string s.
    
        Optional altchars must be a bytes-like object or ASCII string of length 2
        which specifies the alternative alphabet used instead of the '+' and '/'
        characters.
    
        The result is returned as a bytes object.  A binascii.Error is raised if
        s is incorrectly padded.
    
        If validate is False (the default), characters that are neither in the
        normal base-64 alphabet nor the alternative alphabet are discarded prior
        to the padding check.  If validate is True, these non-alphabet characters
        in the input result in a binascii.Error.
        For more information about the strict base64 check, see:
    
        https://docs.python.org/3.11/library/binascii.html#binascii.a2b_base64
        """
        s = _bytes_from_decode_data(s)
        if altchars is not None:
            altchars = _bytes_from_decode_data(altchars)
            assert len(altchars) == 2, repr(altchars)
            s = s.translate(bytes.maketrans(altchars, b'+/'))
>       return binascii.a2b_base64(s, strict_mode=validate)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       binascii.Error: Invalid base64-encoded string: number of data characters (33) cannot be 1 more than a multiple of 4

/usr/lib/python3.11/base64.py:88: Error

The above exception was the direct cause of the following exception:

self = <tests.auth.test_api_key_rotation.TestApiKeyRotation object at 0x7fcff1a4af90>
app = <Flask 'tests.auth.test_api_key_rotation'>
test_org = <Organization Test Organization (test-org)>
test_agent = <Agent d46171f1-91b5-4b0b-a1f6-e0f6792f3a1f 'Test Agent for Rotation'>

    def test_api_key_rotation(self, app, test_org, test_agent):
        """Test API key secret rotation."""
        with app.app_context():
            with patch.dict(
                os.environ, {"BRIKK_ENCRYPTION_KEY": "test_key_32_bytes_long_for_fernet"}
            ):
                # Create initial API key
>               api_key, original_secret = ApiKey.create_api_key(
                    organization_id=test_org.id,
                    name="Test Key for Rotation",
                    agent_id=test_agent.id,
                )

tests/auth/test_api_key_rotation.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/models/api_key.py:79: in create_api_key
    fernet = get_fernet()
             ^^^^^^^^^^^^
src/models/api_key.py:23: in get_fernet
    return Fernet(encryption_key.encode())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cryptography.fernet.Fernet object at 0x7fcff0170290>
key = b'test_key_32_bytes_long_for_fernet', backend = None

    def __init__(
        self,
        key: bytes | str,
        backend: typing.Any = None,
    ) -> None:
        try:
            key = base64.urlsafe_b64decode(key)
        except binascii.Error as exc:
>           raise ValueError(
                "Fernet key must be 32 url-safe base64-encoded bytes."
            ) from exc
E           ValueError: Fernet key must be 32 url-safe base64-encoded bytes.

/usr/local/lib/python3.11/dist-packages/cryptography/fernet.py:37: ValueError
________ TestAuthMiddleware.test_authenticate_request_feature_disabled _________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7fcff17af810>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7fcff0170690>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:20.573642+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:20.573777+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
{"timestamp": "2025-10-13T03:37:21.262352+00:00", "level": "WARNING", "logger": "brikk.monitoring", "message": "Redis not available for metrics storage: Error 111 connecting to localhost:6379. Connection refused.", "module": "structured_logging", "function": "_log_with_context", "line": 85}
_________ TestAuthMiddleware.test_authenticate_request_missing_headers _________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7fcff17afed0>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7fcfee4f1090>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:21.433791+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:21.433921+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
________ TestAuthMiddleware.test_authenticate_request_invalid_timestamp ________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7fcff17af9d0>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7fcfeea92010>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:21.678150+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:21.678292+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_________ TestAuthMiddleware.test_authenticate_request_invalid_api_key _________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7fcff17ae5d0>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7fcfee6bce10>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:21.833539+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:21.833653+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
__________ TestAuthMiddleware.test_check_idempotency_feature_disabled __________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7fcff17abfd0>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7fcfee6794d0>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:21.989226+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:21.989332+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
______________ TestAuthMiddleware.test_check_idempotency_no_auth _______________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7fcff17a8ed0>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7fcfee6bf750>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:22.233505+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:22.233628+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
______________ TestAuthMiddleware.test_check_idempotency_success _______________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7fcff17bc350>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7fcfeea530d0>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:22.390850+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:22.390960+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_______________ TestAuthMiddleware.test_check_idempotency_replay _______________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7fcff17bc750>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7fcfee47e2d0>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:22.546707+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:22.546812+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
___________________ TestAuthMiddleware.test_set_auth_context ___________________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7fcff17bcb50>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7fcfee5aec90>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:22.795348+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:22.795476+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_______________ TestAuthMiddleware.test_log_auth_result_success ________________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7fcff17bcf50>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7fcfee8568d0>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:22.948601+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:22.948703+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_______________ TestAuthMiddleware.test_log_auth_result_failure ________________

args = (<tests.auth.test_hmac_auth.TestAuthMiddleware object at 0x7fcff17bd350>,)
keywargs = {'app': <Flask 'src.factory'>, 'auth_middleware': <src.services.auth_middleware.AuthMiddleware object at 0x7fcfee30cfd0>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/contextlib.py:502: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:1450: in __enter__
    if spec is None and _is_async_obj(original):
                        ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.11/unittest/mock.py:55: in _is_async_obj
    if hasattr(obj, '__func__'):
       ^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/usr/local/lib/python3.11/dist-packages/werkzeug/local.py:519: RuntimeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:23.103006+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:23.103126+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
___ TestIdempotencyService.test_process_request_idempotency_with_custom_key ____

self = <tests.auth.test_idempotency.TestIdempotencyService object at 0x7fcff17cad50>
app = <Flask 'src.factory'>
idempotency_service = <src.services.idempotency.IdempotencyService object at 0x7fcfee745750>
mock_redis = <MagicMock id='140531035627536'>

    def test_process_request_idempotency_with_custom_key(self, app: Flask, idempotency_service, mock_redis):
        """Test idempotency processing with custom idempotency key."""
        key_id = "bk_test_key"
        body_hash = "abc123"
        custom_key = "custom_idem_key"
    
        # No cached response
        mock_redis.get.return_value = None
    
        with app.app_context():
            should_process, response, status = idempotency_service.process_request_idempotency(
                key_id, body_hash, custom_key
            )
    
        assert should_process
        assert response is None
        assert status is None
    
        # Should check for custom idempotency key
        expected_idem_key = idempotency_service.generate_idempotency_key(key_id, "", custom_key)
>       mock_redis.get.assert_called_with(expected_idem_key)

tests/auth/test_idempotency.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='mock.get' id='140531035565200'>
args = ('idem:bk_test_key::custom_idem_key',), kwargs = {}
expected = call('idem:bk_test_key::custom_idem_key')
actual = call('idem:bk_test_key:abc123')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fcfee560f40>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\nActual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: get('idem:bk_test_key::custom_idem_key')
E           Actual: get('idem:bk_test_key:abc123')

/usr/lib/python3.11/unittest/mock.py:923: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:23.547483+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:23.547568+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_____________________________ test_health_endpoint _____________________________

    def test_health_endpoint():
        """Test the health check endpoint if it exists."""
        app = create_app()
        with app.test_client() as client:
            response = client.get('/api/inbound/_health')
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_basic.py:35: AssertionError
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:23.743644+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:23.743728+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
{"timestamp": "2025-10-13T03:37:23.865107+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/inbound/_health", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "GET", "path": "/api/inbound/_health", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:37:23.865853+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/inbound/_health - 404 (0.57ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "77b7b4c6-1a1e-434f-a8a8-3af78c40bf55", "method": "GET", "path": "/api/inbound/_health", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.57, "event_type": "request_end", "status_code": 404, "content_length": 207}
__________________________ test_inbound_ping_endpoint __________________________

    def test_inbound_ping_endpoint():
        """Test the inbound ping endpoint."""
        app = create_app()
        with app.test_client() as client:
            response = client.get('/api/inbound/_ping')
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_basic.py:43: AssertionError
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:23.870281+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:23.870379+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
{"timestamp": "2025-10-13T03:37:23.894945+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/inbound/_ping", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "GET", "path": "/api/inbound/_ping", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:37:23.895397+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/inbound/_ping - 404 (0.31ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "2c5e7575-8edb-4136-b276-a7b1c36f1310", "method": "GET", "path": "/api/inbound/_ping", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.31, "event_type": "request_end", "status_code": 404, "content_length": 207}
____________________ test_billing_portal_request_validation ____________________

client = <FlaskClient <Flask 'src.factory'>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fcfee4b7590>

    def test_billing_portal_request_validation(client, monkeypatch):
        """Test request payload validation and processing."""
        os.environ["STRIPE_SECRET_KEY"] = "sk_test_dummy"
    
        # Mock successful Stripe session creation
        mock_stripe = MagicMock()
        mock_session = MagicMock()
        mock_session.url = "https://billing.stripe.com/session/test"
        mock_stripe.billing_portal.Session.create.return_value = mock_session
    
        with patch('src.routes.billing.stripe', mock_stripe):
            # Test with valid customer_id
            resp = client.post("/api/billing/portal", json={"customer_id": "cus_valid"})
    
>           assert resp.status_code == 200
E           assert 502 == 200
E            +  where 502 = <WrapperTestResponse streamed [502 BAD GATEWAY]>.status_code

tests/test_billing_portal_stripe13.py:68: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:24.313641+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:24.313731+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:24.340810+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/billing/portal", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/billing/portal", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 28}
{"timestamp": "2025-10-13T03:37:24.341145+00:00", "level": "INFO", "logger": "stripe", "message": "message='Request to Stripe api' method=post url=https://api.stripe.com/v1/billing_portal/sessions", "module": "_util", "function": "log_info", "line": 127, "request_id": "b421e06c-2055-422f-ba1b-2b69400f86e0", "method": "POST", "path": "/api/billing/portal", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.25}
{"timestamp": "2025-10-13T03:37:24.344445+00:00", "level": "INFO", "logger": "stripe", "message": "message='Stripe API response' path=https://api.stripe.com/v1/billing_portal/sessions response_code=401", "module": "_util", "function": "log_info", "line": 127, "request_id": "b421e06c-2055-422f-ba1b-2b69400f86e0", "method": "POST", "path": "/api/billing/portal", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 3.57}
{"timestamp": "2025-10-13T03:37:24.344623+00:00", "level": "INFO", "logger": "stripe", "message": "error_code=None error_message='Invalid API Key provided: sk_test_*ummy' error_param=None error_type=invalid_request_error message='Stripe v1 API error received'", "module": "_util", "function": "log_info", "line": 127, "request_id": "b421e06c-2055-422f-ba1b-2b69400f86e0", "method": "POST", "path": "/api/billing/portal", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 3.72}
{"timestamp": "2025-10-13T03:37:24.344808+00:00", "level": "ERROR", "logger": "src.factory", "message": "Stripe error: Invalid API Key provided: sk_test_*ummy", "module": "app", "function": "billing_portal", "line": 145, "request_id": "b421e06c-2055-422f-ba1b-2b69400f86e0", "method": "POST", "path": "/api/billing/portal", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 3.9}
{"timestamp": "2025-10-13T03:37:24.345045+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/billing/portal - 502 (4.09ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "b421e06c-2055-422f-ba1b-2b69400f86e0", "method": "POST", "path": "/api/billing/portal", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 4.09, "event_type": "request_end", "status_code": 502, "content_length": 66}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/billing/portal
INFO     stripe:_util.py:127 message='Request to Stripe api' method=post url=https://api.stripe.com/v1/billing_portal/sessions
INFO     stripe:_util.py:127 message='Stripe API response' path=https://api.stripe.com/v1/billing_portal/sessions response_code=401
INFO     stripe:_util.py:127 error_code=None error_message='Invalid API Key provided: sk_test_*ummy' error_param=None error_type=invalid_request_error message='Stripe v1 API error received'
ERROR    src.factory:app.py:145 Stripe error: Invalid API Key provided: sk_test_*ummy
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/billing/portal - 502 (4.09ms)
__________ TestCoordinationAuth.test_coordination_endpoint_flags_off ___________

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14bf750>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    def test_coordination_endpoint_flags_off(self, client, valid_envelope):
        """Test coordination endpoint with all feature flags OFF."""
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
>           assert response.status_code == 202
E           assert 422 == 202
E            +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_auth.py:104: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:24.376571+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:24.376655+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:24.402560+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:37:24.403859+00:00", "level": "ERROR", "logger": "src.services.rate_limit", "message": "Failed to connect to Redis: Error 111 connecting to localhost:6379. Connection refused.", "module": "rate_limit", "function": "_create_redis_client", "line": 94, "request_id": "16504dc1-0b90-4005-879a-59e8da06f77c", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 1.2}
{"timestamp": "2025-10-13T03:37:24.405055+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (2.33ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "16504dc1-0b90-4005-879a-59e8da06f77c", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 2.33, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
ERROR    src.services.rate_limit:rate_limit.py:94 Failed to connect to Redis: Error 111 connecting to localhost:6379. Connection refused.
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (2.33ms)
__________ TestCoordinationAuth.test_coordination_endpoint_valid_hmac __________

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14bfdd0>
mock_query = <MagicMock name='query' id='140531033268112'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}
mock_api_key = <MagicMock name='query.filter_by().first()' id='140531029202256'>

    @patch('src.models.api_key.ApiKey.query')
    def test_coordination_endpoint_valid_hmac(self, mock_query, client, valid_envelope, mock_api_key):
        """Test coordination endpoint with valid HMAC authentication."""
        mock_query.filter_by.return_value.first.return_value = mock_api_key
    
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            body = json.dumps(valid_envelope).encode()
>           headers = self.create_hmac_headers(
                'POST', '/api/v1/coordination', body, 'test-secret-key',
                valid_envelope['message_id']
            )

tests/test_coordination_auth.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14bfdd0>
method = 'POST', path = '/api/v1/coordination'
body = b'{"version": "1.0", "message_id": "01234567-89ab-cdef-0123-456789abcdef", "ts": "2025-10-13T03:37:24.436704+00:00", "...: {"agent_id": "test-agent"}, "recipient": {"agent_id": "target-agent"}, "payload": {"test": "data"}, "ttl_ms": 30000}'
secret = 'test-secret-key', message_id = '01234567-89ab-cdef-0123-456789abcdef'
timestamp = '2025-10-13T03:37:24.438872+00:00'

    def create_hmac_headers(self, method: str, path: str, body: bytes,
                          secret: str, message_id: str = "",
                          timestamp: str = None) -> dict:
        """Create valid HMAC headers for testing."""
        if timestamp is None:
            timestamp = datetime.now(timezone.utc).isoformat()
    
>       signature = HMACSecurityService.generate_signature(
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            method=method,
            path=path,
            timestamp=timestamp,
            body=body,
            secret=secret,
            message_id=message_id
        )
E       AttributeError: type object 'HMACSecurityService' has no attribute 'generate_signature'

tests/test_coordination_auth.py:76: AttributeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:24.412482+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:24.412574+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_______ TestCoordinationAuth.test_coordination_endpoint_missing_headers ________

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14adcd0>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    def test_coordination_endpoint_missing_headers(self, client, valid_envelope):
        """Test coordination endpoint with missing HMAC headers."""
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
>           assert response.status_code == 400
E           assert 401 == 400
E            +  where 401 = <WrapperTestResponse streamed [401 UNAUTHORIZED]>.status_code

tests/test_coordination_auth.py:154: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:24.447806+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:24.447894+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:24.472740+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:37:24.473102+00:00", "level": "WARNING", "logger": "brikk.auth", "message": "Authentication hmac_verification: failure", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "67d0ed03-4692-4a2b-b4c8-6098b2878ffa", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.27, "event_type": "auth_event", "auth_event": "hmac_verification", "success": false, "failure_reason": "unauthorized", "status_code": 401}
{"timestamp": "2025-10-13T03:37:24.473193+00:00", "level": "WARNING", "logger": "brikk.coordination", "message": "Authentication hmac_verification: failure", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "67d0ed03-4692-4a2b-b4c8-6098b2878ffa", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.35, "event_type": "auth_event", "auth_event": "hmac_verification", "success": false, "failure_reason": "unauthorized"}
{"timestamp": "2025-10-13T03:37:24.473431+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 401 (0.55ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "bb5dc838-3f96-4b2d-ae09-70eb653366a6", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.55, "event_type": "request_end", "status_code": 401, "content_length": 158}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
WARNING  brikk.auth:structured_logging.py:85 Authentication hmac_verification: failure
WARNING  brikk.coordination:structured_logging.py:85 Authentication hmac_verification: failure
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 401 (0.55ms)
_______ TestCoordinationAuth.test_coordination_endpoint_invalid_api_key ________

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14c8290>
mock_query = <MagicMock name='query' id='140531026679824'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    @patch('src.models.api_key.ApiKey.query')
    def test_coordination_endpoint_invalid_api_key(self, mock_query, client, valid_envelope):
        """Test coordination endpoint with invalid API key."""
        mock_query.filter_by.return_value.first.return_value = None
    
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            body = json.dumps(valid_envelope).encode()
>           headers = self.create_hmac_headers(
                'POST', '/api/v1/coordination', body, 'test-secret-key'
            )

tests/test_coordination_auth.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14c8290>
method = 'POST', path = '/api/v1/coordination'
body = b'{"version": "1.0", "message_id": "01234567-89ab-cdef-0123-456789abcdef", "ts": "2025-10-13T03:37:24.504512+00:00", "...: {"agent_id": "test-agent"}, "recipient": {"agent_id": "target-agent"}, "payload": {"test": "data"}, "ttl_ms": 30000}'
secret = 'test-secret-key', message_id = ''
timestamp = '2025-10-13T03:37:24.505736+00:00'

    def create_hmac_headers(self, method: str, path: str, body: bytes,
                          secret: str, message_id: str = "",
                          timestamp: str = None) -> dict:
        """Create valid HMAC headers for testing."""
        if timestamp is None:
            timestamp = datetime.now(timezone.utc).isoformat()
    
>       signature = HMACSecurityService.generate_signature(
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            method=method,
            path=path,
            timestamp=timestamp,
            body=body,
            secret=secret,
            message_id=message_id
        )
E       AttributeError: type object 'HMACSecurityService' has no attribute 'generate_signature'

tests/test_coordination_auth.py:76: AttributeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:24.480381+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:24.480480+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
______ TestCoordinationAuth.test_coordination_endpoint_invalid_signature _______

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14c86d0>
mock_query = <MagicMock name='query' id='140531028310288'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}
mock_api_key = <MagicMock name='query.filter_by().first()' id='140531027093520'>

    @patch('src.models.api_key.ApiKey.query')
    def test_coordination_endpoint_invalid_signature(self, mock_query, client, valid_envelope, mock_api_key):
        """Test coordination endpoint with invalid HMAC signature."""
        mock_query.filter_by.return_value.first.return_value = mock_api_key
    
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            body = json.dumps(valid_envelope).encode()
            headers = {
                'X-Brikk-Key': 'test-key-id',
                'X-Brikk-Timestamp': datetime.now(timezone.utc).isoformat(),
                'X-Brikk-Signature': 'invalid-signature',
                'Content-Type': 'application/json'
            }
    
            response = client.post(
                '/api/v1/coordination',
                data=body,
                headers=headers
            )
    
            assert response.status_code == 401
            data = response.get_json()
            assert data['code'] == 'unauthorized'
>           assert 'Invalid HMAC signature' in data['message']
E           AssertionError: assert 'Invalid HMAC signature' in 'Authentication required. Please log in or provide valid HMAC headers.'

tests/test_coordination_auth.py:211: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:24.514632+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:24.514717+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:24.540998+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:37:24.541348+00:00", "level": "WARNING", "logger": "brikk.auth", "message": "Authentication hmac_verification: failure", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "7294d26c-66ba-465a-907d-24aee7ea9ab2", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.26, "event_type": "auth_event", "auth_event": "hmac_verification", "success": false, "failure_reason": "unauthorized", "status_code": 401}
{"timestamp": "2025-10-13T03:37:24.541441+00:00", "level": "WARNING", "logger": "brikk.coordination", "message": "Authentication hmac_verification: failure", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "7294d26c-66ba-465a-907d-24aee7ea9ab2", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.36, "event_type": "auth_event", "auth_event": "hmac_verification", "success": false, "failure_reason": "unauthorized"}
{"timestamp": "2025-10-13T03:37:24.541700+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 401 (0.56ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "3d3f78f2-744f-41ee-b49d-6b585c3107fe", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.56, "event_type": "request_end", "status_code": 401, "content_length": 158}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
WARNING  brikk.auth:structured_logging.py:85 Authentication hmac_verification: failure
WARNING  brikk.coordination:structured_logging.py:85 Authentication hmac_verification: failure
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 401 (0.56ms)
_______ TestCoordinationAuth.test_coordination_endpoint_timestamp_drift ________

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14c8b10>
mock_query = <MagicMock name='query' id='140531027446928'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}
mock_api_key = <MagicMock name='query.filter_by().first()' id='140531027449808'>

    @patch('src.models.api_key.ApiKey.query')
    def test_coordination_endpoint_timestamp_drift(self, mock_query, client, valid_envelope, mock_api_key):
        """Test coordination endpoint with timestamp outside drift window."""
        mock_query.filter_by.return_value.first.return_value = mock_api_key
    
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            # Create timestamp 400 seconds in the past (outside '+/-300s window)
            old_timestamp = (datetime.now(timezone.utc) - timedelta(seconds=400)).isoformat()
    
            body = json.dumps(valid_envelope).encode()
>           headers = self.create_hmac_headers(
                'POST', '/api/v1/coordination', body, 'test-secret-key',
                valid_envelope['message_id'], old_timestamp
            )

tests/test_coordination_auth.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14c8b10>
method = 'POST', path = '/api/v1/coordination'
body = b'{"version": "1.0", "message_id": "01234567-89ab-cdef-0123-456789abcdef", "ts": "2025-10-13T03:37:24.573541+00:00", "...: {"agent_id": "test-agent"}, "recipient": {"agent_id": "target-agent"}, "payload": {"test": "data"}, "ttl_ms": 30000}'
secret = 'test-secret-key', message_id = '01234567-89ab-cdef-0123-456789abcdef'
timestamp = '2025-10-13T03:30:44.575288+00:00'

    def create_hmac_headers(self, method: str, path: str, body: bytes,
                          secret: str, message_id: str = "",
                          timestamp: str = None) -> dict:
        """Create valid HMAC headers for testing."""
        if timestamp is None:
            timestamp = datetime.now(timezone.utc).isoformat()
    
>       signature = HMACSecurityService.generate_signature(
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            method=method,
            path=path,
            timestamp=timestamp,
            body=body,
            secret=secret,
            message_id=message_id
        )
E       AttributeError: type object 'HMACSecurityService' has no attribute 'generate_signature'

tests/test_coordination_auth.py:76: AttributeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:24.549186+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:24.549274+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
______ TestCoordinationAuth.test_coordination_endpoint_idempotent_replay _______

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14c8f50>
mock_idempotency = <MagicMock name='process_request_idempotency' id='140531024647696'>
mock_query = <MagicMock name='query' id='140531026084752'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}
mock_api_key = <MagicMock name='query.filter_by().first()' id='140531024625936'>

    @patch('src.models.api_key.ApiKey.query')
    @patch('src.services.idempotency.IdempotencyService.process_request_idempotency')
    def test_coordination_endpoint_idempotent_replay(self, mock_idempotency, mock_query,
                                                   client, valid_envelope, mock_api_key):
        """Test coordination endpoint with idempotent replay (same request)."""
        mock_query.filter_by.return_value.first.return_value = mock_api_key
    
        # Mock idempotency service to return cached response
        cached_response = {
            "status": "accepted",
            "echo": {"message_id": valid_envelope['message_id']}
        }
        mock_idempotency.return_value = (False, cached_response, 202)
    
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'true'
        }):
            body = json.dumps(valid_envelope).encode()
>           headers = self.create_hmac_headers(
                'POST', '/api/v1/coordination', body, 'test-secret-key',
                valid_envelope['message_id']
            )

tests/test_coordination_auth.py:267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14c8f50>
method = 'POST', path = '/api/v1/coordination'
body = b'{"version": "1.0", "message_id": "01234567-89ab-cdef-0123-456789abcdef", "ts": "2025-10-13T03:37:24.607936+00:00", "...: {"agent_id": "test-agent"}, "recipient": {"agent_id": "target-agent"}, "payload": {"test": "data"}, "ttl_ms": 30000}'
secret = 'test-secret-key', message_id = '01234567-89ab-cdef-0123-456789abcdef'
timestamp = '2025-10-13T03:37:24.609885+00:00'

    def create_hmac_headers(self, method: str, path: str, body: bytes,
                          secret: str, message_id: str = "",
                          timestamp: str = None) -> dict:
        """Create valid HMAC headers for testing."""
        if timestamp is None:
            timestamp = datetime.now(timezone.utc).isoformat()
    
>       signature = HMACSecurityService.generate_signature(
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            method=method,
            path=path,
            timestamp=timestamp,
            body=body,
            secret=secret,
            message_id=message_id
        )
E       AttributeError: type object 'HMACSecurityService' has no attribute 'generate_signature'

tests/test_coordination_auth.py:76: AttributeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:24.584154+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:24.584239+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_____ TestCoordinationAuth.test_coordination_endpoint_idempotency_conflict _____

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14c9390>
mock_idempotency = <MagicMock name='process_request_idempotency' id='140531025241040'>
mock_query = <MagicMock name='query' id='140531026057552'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}
mock_api_key = <MagicMock name='query.filter_by().first()' id='140531025348752'>

    @patch('src.models.api_key.ApiKey.query')
    @patch('src.services.idempotency.IdempotencyService.process_request_idempotency')
    def test_coordination_endpoint_idempotency_conflict(self, mock_idempotency, mock_query,
                                                      client, valid_envelope, mock_api_key):
        """Test coordination endpoint with idempotency conflict (same key, different body)."""
        mock_query.filter_by.return_value.first.return_value = mock_api_key
    
        # Mock idempotency service to return conflict
        mock_idempotency.return_value = (False, {'code': 'idempotency_conflict', 'message': 'Idempotency key conflicts with previous request'}, 409)
    
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'true'
        }):
            body = json.dumps(valid_envelope).encode()
>           headers = self.create_hmac_headers(
                'POST', '/api/v1/coordination', body, 'test-secret-key',
                valid_envelope['message_id']
            )

tests/test_coordination_auth.py:298: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14c9390>
method = 'POST', path = '/api/v1/coordination'
body = b'{"version": "1.0", "message_id": "01234567-89ab-cdef-0123-456789abcdef", "ts": "2025-10-13T03:37:24.643535+00:00", "...: {"agent_id": "test-agent"}, "recipient": {"agent_id": "target-agent"}, "payload": {"test": "data"}, "ttl_ms": 30000}'
secret = 'test-secret-key', message_id = '01234567-89ab-cdef-0123-456789abcdef'
timestamp = '2025-10-13T03:37:24.759507+00:00'

    def create_hmac_headers(self, method: str, path: str, body: bytes,
                          secret: str, message_id: str = "",
                          timestamp: str = None) -> dict:
        """Create valid HMAC headers for testing."""
        if timestamp is None:
            timestamp = datetime.now(timezone.utc).isoformat()
    
>       signature = HMACSecurityService.generate_signature(
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            method=method,
            path=path,
            timestamp=timestamp,
            body=body,
            secret=secret,
            message_id=message_id
        )
E       AttributeError: type object 'HMACSecurityService' has no attribute 'generate_signature'

tests/test_coordination_auth.py:76: AttributeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:24.619164+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:24.619256+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
____________ TestCoordinationAuth.test_coordination_health_endpoint ____________

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14ca6d0>
client = <FlaskClient <Flask 'src.factory'>>

    def test_coordination_health_endpoint(self, client):
        """Test coordination health check endpoint."""
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'true',
            'BRIKK_ALLOW_UUID4': 'false'
        }):
            response = client.get('/api/v1/coordination/health')
    
            assert response.status_code == 200
            data = response.get_json()
            assert data['status'] == 'healthy'
            assert data['service'] == 'coordination-api'
            assert data['version'] == '1.0'
            assert 'features' in data
>           assert data['features']['per_org_keys'] is True
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'per_org_keys'

tests/test_coordination_auth.py:376: KeyError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:24.826092+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:24.826183+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:24.850719+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/v1/coordination/health", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "GET", "path": "/api/v1/coordination/health", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:37:24.851192+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/v1/coordination/health - 200 (0.33ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "b72da597-1c07-4b45-93cc-ffd3a2d3d091", "method": "GET", "path": "/api/v1/coordination/health", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.33, "event_type": "request_end", "status_code": 200, "content_length": 183}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: GET /api/v1/coordination/health
INFO     brikk.requests:structured_logging.py:85 Request completed: GET /api/v1/coordination/health - 200 (0.33ms)
______________ TestCoordinationAuth.test_security_headers_present ______________

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14cad90>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    def test_security_headers_present(self, client, valid_envelope):
        """Test that security headers are present in responses."""
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
>           assert response.status_code == 202
E           assert 422 == 202
E            +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_auth.py:392: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:24.858903+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:24.858988+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:24.883063+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:37:24.883675+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (0.47ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "583c3e68-277d-498e-84f1-38932891acc8", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.47, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (0.47ms)
_ TestCoordinationAuth.test_coordination_endpoint_with_custom_idempotency_key __

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14cb410>
mock_query = <MagicMock name='query' id='140531026087568'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}
mock_api_key = <MagicMock name='query.filter_by().first()' id='140531028968848'>

    @patch('src.models.api_key.ApiKey.query')
    def test_coordination_endpoint_with_custom_idempotency_key(self, mock_query, client,
                                                             valid_envelope, mock_api_key):
        """Test coordination endpoint with custom Idempotency-Key header."""
        mock_query.filter_by.return_value.first.return_value = mock_api_key
    
        with patch.dict(os.environ, {
            'BRIKK_FEATURE_PER_ORG_KEYS': 'true',
            'BRIKK_IDEM_ENABLED': 'true'
        }):
            body = json.dumps(valid_envelope).encode()
>           headers = self.create_hmac_headers(
                'POST', '/api/v1/coordination', body, 'test-secret-key',
                valid_envelope['message_id']
            )

tests/test_coordination_auth.py:414: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_coordination_auth.TestCoordinationAuth object at 0x7fcff14cb410>
method = 'POST', path = '/api/v1/coordination'
body = b'{"version": "1.0", "message_id": "01234567-89ab-cdef-0123-456789abcdef", "ts": "2025-10-13T03:37:24.914940+00:00", "...: {"agent_id": "test-agent"}, "recipient": {"agent_id": "target-agent"}, "payload": {"test": "data"}, "ttl_ms": 30000}'
secret = 'test-secret-key', message_id = '01234567-89ab-cdef-0123-456789abcdef'
timestamp = '2025-10-13T03:37:24.916776+00:00'

    def create_hmac_headers(self, method: str, path: str, body: bytes,
                          secret: str, message_id: str = "",
                          timestamp: str = None) -> dict:
        """Create valid HMAC headers for testing."""
        if timestamp is None:
            timestamp = datetime.now(timezone.utc).isoformat()
    
>       signature = HMACSecurityService.generate_signature(
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            method=method,
            path=path,
            timestamp=timestamp,
            body=body,
            secret=secret,
            message_id=message_id
        )
E       AttributeError: type object 'HMACSecurityService' has no attribute 'generate_signature'

tests/test_coordination_auth.py:76: AttributeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:24.890895+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:24.890981+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
___________ TestCoordinationEndpoint.test_valid_request_returns_202 ____________

self = <tests.test_coordination_stub.TestCoordinationEndpoint object at 0x7fcff0af1f50>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_headers = {'Content-Type': 'application/json', 'X-Brikk-Key': 'test-key-123', 'X-Brikk-Signature': 'test-signature-abc123', 'X-Brikk-Timestamp': '1696248600'}
valid_envelope = {'message_id': '8771ba9f-5051-47e8-957a-2334ffbad995', 'payload': {'action': 'coordinate', 'data': {'key': 'value'}}, 'recipient': {'agent_id': 'test-recipient-002'}, 'sender': {'agent_id': 'test-sender-001'}, ...}

    def test_valid_request_returns_202(self, client, valid_headers, valid_envelope):
        """Test that valid request returns 202 with echo."""
        response = client.post(
            '/api/v1/coordination',
            headers=valid_headers,
            json=valid_envelope
        )
    
>       assert response.status_code == 202
E       assert 422 == 202
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_stub.py:74: AssertionError
_____________ TestCoordinationEndpoint.test_minimal_valid_envelope _____________

self = <tests.test_coordination_stub.TestCoordinationEndpoint object at 0x7fcff0af2610>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_headers = {'Content-Type': 'application/json', 'X-Brikk-Key': 'test-key-123', 'X-Brikk-Signature': 'test-signature-abc123', 'X-Brikk-Timestamp': '1696248600'}

    def test_minimal_valid_envelope(self, client, valid_headers):
        """Test that minimal valid envelope is accepted."""
        minimal_envelope = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "type": "command",
            "sender": {'agent_id': "sender-001"},
            "recipient": {'agent_id': "recipient-002"},
            "payload": {'action': "test"}
        }
    
        response = client.post(
            '/api/v1/coordination',
            headers=valid_headers,
            json=minimal_envelope
        )
    
>       assert response.status_code == 202
E       assert 422 == 202
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_stub.py:98: AssertionError
____________ TestCoordinationEndpoint.test_security_headers_present ____________

self = <tests.test_coordination_stub.TestCoordinationEndpoint object at 0x7fcff0af2d10>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_headers = {'Content-Type': 'application/json', 'X-Brikk-Key': 'test-key-123', 'X-Brikk-Signature': 'test-signature-abc123', 'X-Brikk-Timestamp': '1696248600'}
valid_envelope = {'message_id': '164385d7-76b7-4c3d-81bb-eb502cfab395', 'payload': {'action': 'coordinate', 'data': {'key': 'value'}}, 'recipient': {'agent_id': 'test-recipient-002'}, 'sender': {'agent_id': 'test-sender-001'}, ...}

    def test_security_headers_present(self, client, valid_headers, valid_envelope):
        """Test that security headers are present in response."""
        response = client.post(
            '/api/v1/coordination',
            headers=valid_headers,
            json=valid_envelope
        )
    
>       assert response.status_code == 202
E       assert 422 == 202
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_stub.py:110: AssertionError
______ TestRequestGuardsIntegration.test_missing_content_type_returns_415 ______

self = <tests.test_coordination_stub.TestRequestGuardsIntegration object at 0x7fcff0af35d0>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_envelope = {'message_id': 'd3bcac1a-2249-427a-985b-59561b0e6175', 'payload': {'action': 'coordinate', 'data': {'key': 'value'}}, 'recipient': {'agent_id': 'test-recipient-002'}, 'sender': {'agent_id': 'test-sender-001'}, ...}

    def test_missing_content_type_returns_415(self, client, valid_envelope):
        """Test that missing Content-Type returns 415."""
        headers = {
            'X-Brikk-Key': 'test-key',
            'X-Brikk-Timestamp': '1696248600',
            'X-Brikk-Signature': 'test-signature'
        }
    
        response = client.post(
            '/api/v1/coordination',
            headers=headers,
            data=json.dumps(valid_envelope)
        )
    
>       assert response.status_code == 415
E       assert 400 == 415
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code

tests/test_coordination_stub.py:135: AssertionError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/home/ubuntu/brikk-infrastructure/src/routes/coordination.py", line 232, in coordination_endpoint
    json_data = request.get_json()
                ^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/werkzeug/wrappers/request.py", line 604, in get_json
    return self.on_json_loading_failed(None)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/flask/wrappers.py", line 214, in on_json_loading_failed
    return super().on_json_loading_failed(e)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/werkzeug/wrappers/request.py", line 647, in on_json_loading_failed
    raise UnsupportedMediaType(
werkzeug.exceptions.UnsupportedMediaType: 415 Unsupported Media Type: Did not attempt to load JSON data because the request Content-Type was not 'application/json'.
_____ TestRequestGuardsIntegration.test_missing_brikk_headers_returns_400 ______

self = <tests.test_coordination_stub.TestRequestGuardsIntegration object at 0x7fcff0af3c90>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_envelope = {'message_id': 'a3dfcd65-6557-49f9-bd4c-04e217ce1c44', 'payload': {'action': 'coordinate', 'data': {'key': 'value'}}, 'recipient': {'agent_id': 'test-recipient-002'}, 'sender': {'agent_id': 'test-sender-001'}, ...}

    def test_missing_brikk_headers_returns_400(self, client, valid_envelope):
        """Test that missing Brikk headers return 400."""
        headers = {'Content-Type': 'application/json'}
    
        response = client.post(
            '/api/v1/coordination',
            headers=headers,
            json=valid_envelope
        )
    
>       assert response.status_code == 400
E       assert 422 == 400
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_stub.py:150: AssertionError
_________ TestRequestGuardsIntegration.test_oversized_body_returns_413 _________

self = <tests.test_coordination_stub.TestRequestGuardsIntegration object at 0x7fcff0908390>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_headers = {'Content-Type': 'application/json', 'X-Brikk-Key': 'test-key-123', 'X-Brikk-Signature': 'test-signature-abc123', 'X-Brikk-Timestamp': '1696248600'}

    def test_oversized_body_returns_413(self, client, valid_headers):
        """Test that oversized request body returns 413."""
        # Create large payload
        large_payload = {'data': "x" * (256 * 1024 + 1000)}  # >256KB
        large_envelope = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "type": "command",
            "sender": {'agent_id': "sender-001"},
            "recipient": {'agent_id': "recipient-002"},
            "payload": large_payload
        }
    
        response = client.post(
            '/api/v1/coordination',
            headers=valid_headers,
            json=large_envelope
        )
    
>       assert response.status_code == 413
E       assert 422 == 413
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_stub.py:177: AssertionError
__ TestEnvelopeValidationIntegration.test_missing_required_fields_returns_422 __

self = <tests.test_coordination_stub.TestEnvelopeValidationIntegration object at 0x7fcff09092d0>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_headers = {'Content-Type': 'application/json', 'X-Brikk-Key': 'test-key-123', 'X-Brikk-Signature': 'test-signature-abc123', 'X-Brikk-Timestamp': '1696248600'}

    def test_missing_required_fields_returns_422(self, client, valid_headers):
        """Test that missing required fields return 422."""
        incomplete_envelope = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            # Missing sender, recipient, payload, type
        }
    
        response = client.post(
            '/api/v1/coordination',
            headers=valid_headers,
            json=incomplete_envelope
        )
    
        assert response.status_code == 422
        data = response.get_json()
        assert data['code'] == 'validation_error'
        assert 'details' in data
    
        # Check that all missing fields are reported
        details_str = ' '.join(str(d) for d in data['details'])
        assert 'sender' in details_str
        assert 'recipient' in details_str
        assert 'payload' in details_str
>       assert 'type' in details_str
E       AssertionError: assert 'type' in 'message_id: Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. sender: Field required recipient: Field required payload: Field required'

tests/test_coordination_stub.py:234: AssertionError
_________ TestErrorHandling.test_error_responses_have_security_headers _________

self = <tests.test_coordination_stub.TestErrorHandling object at 0x7fcff0910610>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_headers = {'Content-Type': 'application/json', 'X-Brikk-Key': 'test-key-123', 'X-Brikk-Signature': 'test-signature-abc123', 'X-Brikk-Timestamp': '1696248600'}

    def test_error_responses_have_security_headers(self, client, valid_headers):
        """Test that error responses include security headers."""
        response = client.post(
            '/api/v1/coordination',
            headers={'Content-Type': 'text/plain'},  # Wrong content type
            data='test'
        )
    
>       assert response.status_code == 415
E       assert 400 == 415
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code

tests/test_coordination_stub.py:335: AssertionError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/home/ubuntu/brikk-infrastructure/src/routes/coordination.py", line 232, in coordination_endpoint
    json_data = request.get_json()
                ^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/werkzeug/wrappers/request.py", line 604, in get_json
    return self.on_json_loading_failed(None)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/flask/wrappers.py", line 214, in on_json_loading_failed
    return super().on_json_loading_failed(e)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/werkzeug/wrappers/request.py", line 647, in on_json_loading_failed
    raise UnsupportedMediaType(
werkzeug.exceptions.UnsupportedMediaType: 415 Unsupported Media Type: Did not attempt to load JSON data because the request Content-Type was not 'application/json'.
____________ TestHealthCheckEndpoint.test_health_check_returns_200 _____________

self = <tests.test_coordination_stub.TestHealthCheckEndpoint object at 0x7fcff0910e90>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>

    def test_health_check_returns_200(self, client):
        """Test that health check endpoint returns 200."""
        response = client.get('/api/v1/coordination/health')
    
        assert response.status_code == 200
        data = response.get_json()
    
        assert data['status'] == 'healthy'
        assert data['service'] == 'coordination-api'
>       assert data['version'] == '1.0-stub'
E       AssertionError: assert '1.0' == '1.0-stub'
E         
E         - 1.0-stub
E         + 1.0

tests/test_coordination_stub.py:355: AssertionError
_______________ TestMessageTypes.test_all_message_types_accepted _______________

self = <tests.test_coordination_stub.TestMessageTypes object at 0x7fcff0910450>
client = <FlaskClient <Flask 'tests.test_coordination_stub'>>
valid_headers = {'Content-Type': 'application/json', 'X-Brikk-Key': 'test-key-123', 'X-Brikk-Signature': 'test-signature-abc123', 'X-Brikk-Timestamp': '1696248600'}

    def test_all_message_types_accepted(self, client, valid_headers):
        """Test that all valid message types are accepted."""
        message_types = ["event", "command", "result", "error"]
    
        for msg_type in message_types:
            envelope = {
                "message_id": str(uuid.uuid4()),
                "ts": "2023-10-02T14:30:00Z",
                "type": msg_type,
                "sender": {'agent_id': "sender-001"},
                "recipient": {'agent_id': "recipient-002"},
                "payload": {'action': "test", 'type': msg_type}
            }
    
            response = client.post(
                '/api/v1/coordination',
                headers=valid_headers,
                json=envelope
            )
    
>           assert response.status_code == 202, f"Failed for message type: {msg_type}"
E           AssertionError: Failed for message type: event
E           assert 422 == 202
E            +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_coordination_stub.py:398: AssertionError
____________________ test_coordination_v1_invalid_signature ____________________

client = <FlaskClient <Flask 'src.factory'>>
org_and_key = (<Organization Test Org (test-org-88ba9449-e75e-46b5-9b96-81561a5cede3)>, <ApiKey bk_yfnA2Ekn-m4G5*** (Test Key)>)

    def test_coordination_v1_invalid_signature(client, org_and_key):
        """Test failed call with invalid signature."""
        org, api_key = org_and_key
        timestamp = str(int(time.time()))
        body = {
            "version": "1.0",
            "message_id": str(uuid.uuid4()),
            "ts": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z",
            "type": "event",
            "sender": {"agent_id": "agent-1"},
            "recipient": {"agent_id": "agent-2"},
            "payload": {"foo": "bar"},
            "ttl_ms": 60000,
        }
        body_str = json.dumps(body)
        signature = "invalid-signature"
    
        headers = {
            "Content-Type": "application/json",
            "X-Brikk-Key": api_key.key_id,
            "X-Brikk-Timestamp": timestamp,
            "X-Brikk-Signature": signature,
        }
    
        response = client.post("/api/v1/coordination", headers=headers, data=body_str)
    
>       assert response.status_code == 401
E       assert 202 == 401
E        +  where 202 = <WrapperTestResponse streamed [202 ACCEPTED]>.status_code

tests/test_coordination_v1.py:131: AssertionError
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:25.082614+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 240}
{"timestamp": "2025-10-13T03:37:25.082994+00:00", "level": "INFO", "logger": "brikk.coordination", "message": "Coordination request processed successfully", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "afd1cce4-1737-4569-b17f-9bd8d1287e8d", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.29, "event_type": "coordination_success", "message_id": "8b10ca85-bf90-4322-93a4-8809ab38ca4a", "message_type": "event", "sender_agent_id": "agent-1", "recipient_agent_id": "agent-2", "ttl_ms": 60000}
{"timestamp": "2025-10-13T03:37:25.083248+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 202 (0.49ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "61614621-e520-4030-af08-f5f8ae1b0a2e", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.49, "event_type": "request_end", "status_code": 202, "content_length": 83}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.coordination:structured_logging.py:85 Coordination request processed successfully
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 202 (0.49ms)
_______________________ test_coordination_v1_idempotency _______________________

client = <FlaskClient <Flask 'src.factory'>>
org_and_key = (<Organization Test Org (test-org-93cdb8f5-b299-489f-afe8-e5c2f6f06443)>, <ApiKey bk_GViY0YDc1_BU4*** (Test Key)>)

    def test_coordination_v1_idempotency(client, org_and_key):
        """Test idempotency handling."""
        org, api_key = org_and_key
        timestamp = str(int(time.time()))
        body = {
            "version": "1.0",
            "message_id": str(uuid.uuid4()),
            "ts": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z",
            "type": "event",
            "sender": {"agent_id": "agent-1"},
            "recipient": {"agent_id": "agent-2"},
            "payload": {"foo": "bar"},
            "ttl_ms": 60000,
        }
        body_str = json.dumps(body)
        signature = generate_signature(timestamp, body_str, api_key.signing_secret)
        idempotency_key = f"idem-key-{uuid.uuid4()}"
    
        headers = {
            "Content-Type": "application/json",
            "X-Brikk-Key": api_key.key_id,
            "X-Brikk-Timestamp": timestamp,
            "X-Brikk-Signature": signature,
            "Idempotency-Key": idempotency_key,
        }
    
        # First request should succeed
        response1 = client.post("/api/v1/coordination", headers=headers, data=body_str)
        assert response1.status_code == 202
    
        # Second request with same idempotency key should be a replay
        response2 = client.post("/api/v1/coordination", headers=headers, data=body_str)
>       assert response2.status_code == 200  # Replay returns 200
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 202 == 200
E        +  where 202 = <WrapperTestResponse streamed [202 ACCEPTED]>.status_code

tests/test_coordination_v1.py:168: AssertionError
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:25.096010+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 240}
{"timestamp": "2025-10-13T03:37:25.096407+00:00", "level": "INFO", "logger": "brikk.coordination", "message": "Coordination request processed successfully", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "38f96e29-6415-42ce-ae9d-934f424e9b67", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.3, "event_type": "coordination_success", "message_id": "9c8fc082-1947-4f16-a08a-0a444ac7d914", "message_type": "event", "sender_agent_id": "agent-1", "recipient_agent_id": "agent-2", "ttl_ms": 60000}
{"timestamp": "2025-10-13T03:37:25.096657+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 202 (0.5ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "e4afb2ac-7e2e-4b86-8112-688575b04ad1", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.5, "event_type": "request_end", "status_code": 202, "content_length": 83}
{"timestamp": "2025-10-13T03:37:25.097094+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "e4afb2ac-7e2e-4b86-8112-688575b04ad1", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.99, "event_type": "request_start", "content_length": 240}
{"timestamp": "2025-10-13T03:37:25.097439+00:00", "level": "INFO", "logger": "brikk.coordination", "message": "Coordination request processed successfully", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "982d5773-594b-4515-9e62-cf213c2d501d", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.28, "event_type": "coordination_success", "message_id": "9c8fc082-1947-4f16-a08a-0a444ac7d914", "message_type": "event", "sender_agent_id": "agent-1", "recipient_agent_id": "agent-2", "ttl_ms": 60000}
{"timestamp": "2025-10-13T03:37:25.097683+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 202 (0.47ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "6fc6cec6-2dd4-45f9-a89c-68bd46eb7c07", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.47, "event_type": "request_end", "status_code": 202, "content_length": 83}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.coordination:structured_logging.py:85 Coordination request processed successfully
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 202 (0.5ms)
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.coordination:structured_logging.py:85 Coordination request processed successfully
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 202 (0.47ms)
____________________________ test_register_service _____________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'agent_id': '5ea49521-383d-4c9a-aba0-c97c355c456e', 'organization_id': '1b4eb706-6ac0-44c6-92a9-258f12404f28'}

    def test_register_service(client: FlaskClient, auth_headers: dict):
        """Test registering a new agent service"""
        service_data = {
            "service_name": "test-service",
            "service_url": "http://localhost:8080/service",
            "capabilities": ["data_processing", "nlp"]
        }
    
        response = client.post("/api/v1/discovery/register", json=service_data, headers=auth_headers)
>       assert response.status_code == 201
E       assert 422 == 201
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_discovery_v1.py:56: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:25.122813+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:25.122905+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:25.191144+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/discovery/register", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 124}
{"timestamp": "2025-10-13T03:37:25.191608+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/discovery/register - 422 (0.32ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "26da49fe-69ad-4057-bb54-1586870e1065", "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.32, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/discovery/register
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/discovery/register - 422 (0.32ms)
____________________________ test_discover_services ____________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'agent_id': '1974b153-271c-4c1b-9137-0e6ce904a265', 'organization_id': '3f0b5213-2cb3-4fbb-877c-4368cbc708b1'}

    def test_discover_services(client: FlaskClient, auth_headers: dict):
        """Test discovering available services"""
        # Register a service first
        client.post("/api/v1/discovery/register", json={
            "service_name": "test-service",
            "service_url": "http://localhost:8080/service",
            "capabilities": ["data_processing"]
        }, headers=auth_headers)
    
        # Discover all services
        response = client.get("/api/v1/discovery/discover", headers=auth_headers)
>       assert response.status_code == 200
E       assert 422 == 200
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_discovery_v1.py:70: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:25.211271+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:25.211364+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:25.279410+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/discovery/register", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 117}
{"timestamp": "2025-10-13T03:37:25.279864+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/discovery/register - 422 (0.29ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "00228bd9-7d4c-4ad3-86ec-d28e795eba2d", "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.29, "event_type": "request_end", "status_code": 422, "content_length": 30}
{"timestamp": "2025-10-13T03:37:25.280343+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/v1/discovery/discover", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "00228bd9-7d4c-4ad3-86ec-d28e795eba2d", "method": "GET", "path": "/api/v1/discovery/discover", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.82, "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:37:25.280719+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/v1/discovery/discover - 422 (0.25ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "cadc589a-09f7-4cbc-99db-b625760146b6", "method": "GET", "path": "/api/v1/discovery/discover", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.25, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/discovery/register
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/discovery/register - 422 (0.29ms)
INFO     brikk.requests:structured_logging.py:85 Request started: GET /api/v1/discovery/discover
INFO     brikk.requests:structured_logging.py:85 Request completed: GET /api/v1/discovery/discover - 422 (0.25ms)
____________________________ test_service_heartbeat ____________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'agent_id': 'b349f11e-d133-4a92-8ee6-5a4aedc8fcb9', 'organization_id': 'a5f0192f-c91c-4afb-abc6-c8daf8810c23'}

    def test_service_heartbeat(client: FlaskClient, auth_headers: dict):
        """Test sending a heartbeat to a service"""
        create_response = client.post("/api/v1/discovery/register", json={
            "service_name": "test-service",
            "service_url": "http://localhost:8080/service",
            "capabilities": []
        }, headers=auth_headers)
>       service_id = create_response.json["id"]
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_discovery_v1.py:91: KeyError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:25.299315+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:25.299405+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:25.370176+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/discovery/register", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 100}
{"timestamp": "2025-10-13T03:37:25.370655+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/discovery/register - 422 (0.31ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "eff0256c-ca1e-4799-9f84-d950ca9e884a", "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.31, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/discovery/register
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/discovery/register - 422 (0.31ms)
___________________________ test_get_service_details ___________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'agent_id': 'badd36dd-79aa-4c54-adb6-682f979d739d', 'organization_id': 'c0d94725-388b-46aa-9321-0cab0354fe6c'}

    def test_get_service_details(client: FlaskClient, auth_headers: dict):
        """Test getting details of a specific service"""
        create_response = client.post("/api/v1/discovery/register", json={
            "service_name": "detailed-service",
            "service_url": "http://localhost:8080/detailed",
            "capabilities": ["test"]
        }, headers=auth_headers)
>       service_id = create_response.json["id"]
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_discovery_v1.py:127: KeyError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:25.489041+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:25.489141+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:25.560720+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/discovery/register", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 111}
{"timestamp": "2025-10-13T03:37:25.561239+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/discovery/register - 422 (0.34ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "eb77a2bf-09c0-4f18-852d-a164e4ad3ca2", "method": "POST", "path": "/api/v1/discovery/register", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.34, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/discovery/register
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/discovery/register - 422 (0.34ms)
_______________________________ test_get_balance _______________________________

client = <FlaskClient <Flask 'src.factory'>>

    def test_get_balance(client: FlaskClient):
        """Test retrieving the credit balance for an organization."""
        # This test requires a valid JWT token with an org_id
        # For now, we will mock the authentication
        headers = {"Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTY3OTg1NjAwMCwianRpIjoiZGV2LWp3dC1pZCIsIm5iZiI6MTY3OTg1NjAwMCwiZXhwIjoxNjc5ODU5NjAwLCJzdWIiOnsiZW1haWwiOiJ0ZXN0QGV4YW1wbGUuY29tIiwib3JnX2lkIjoiZGV2LW9yZy1pZCJ9fQ.mock_signature"}
        response = client.get("/api/v1/billing/balance", headers=headers)
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_economy_api_v1.py:33: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:25.581959+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:25.582054+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:25.647125+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/v1/billing/balance", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "GET", "path": "/api/v1/billing/balance", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:37:25.647661+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/v1/billing/balance - 404 (0.35ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "a1da1739-e393-4560-bdb3-e79eebe152ad", "method": "GET", "path": "/api/v1/billing/balance", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.35, "event_type": "request_end", "status_code": 404, "content_length": 207}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: GET /api/v1/billing/balance
INFO     brikk.requests:structured_logging.py:85 Request completed: GET /api/v1/billing/balance - 404 (0.35ms)
_________________________ test_system_accounts_seeded __________________________

app = <Flask 'src.factory'>

    def test_system_accounts_seeded(app):
        with app.app_context():
            revenue_account = LedgerAccount.query.filter_by(name="platform_revenue").first()
            fees_account = LedgerAccount.query.filter_by(name="platform_fees").first()
            promotions_account = LedgerAccount.query.filter_by(name="promotions").first()
>           assert revenue_account is not None
E           assert None is not None

tests/test_economy_db_v1.py:43: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:25.750415+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:25.750534+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
______________ TestEnvelopeValidation.test_minimal_valid_envelope ______________

self = <tests.test_envelope_validation.TestEnvelopeValidation object at 0x7fcff093fb90>

    def test_minimal_valid_envelope(self):
        """Test that minimal valid envelope passes validation."""
        envelope_data = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00.123Z",
            "sender": {"agent_id": "agent-001"},
            "recipient": {"agent_id": "agent-002"},
            "payload": {"action": "test"}
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='65b6ed58-0d71-4942-9766-cc3b471e413f', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:34: ValidationError
_______________ TestEnvelopeValidation.test_full_valid_envelope ________________

self = <tests.test_envelope_validation.TestEnvelopeValidation object at 0x7fcff093fed0>

    def test_full_valid_envelope(self):
        """Test that envelope with all fields passes validation."""
        envelope_data = {
            "version": "1.0",
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "type": "command",
            "sender": {"agent_id": "agent-001", "org_id": "org-123"},
            "recipient": {"agent_id": "agent-002", "org_id": "org-456"},
            "payload": {"action": "execute", "params": {"key": "value"}},
            "ttl_ms": 60000,
            "reply_to": "msg-reply-123",
            "nonce": "nonce-456"
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='501e6a12-25b2-45b7-b980-364fa0932ba3', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:56: ValidationError
___________________ TestVersionValidation.test_valid_version ___________________

self = <tests.test_envelope_validation.TestVersionValidation object at 0x7fcff0950450>

    def test_valid_version(self):
        """Test that version 1.0 is accepted."""
        envelope_data = {
            "version": "1.0",
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "sender": {"agent_id": "agent-001"},
            "recipient": {"agent_id": "agent-002"},
            "payload": {"action": "test"}
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='7ac9f37f-eab6-4023-a703-ffd2783eae8e', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:78: ValidationError
___________________ TestMessageIdValidation.test_valid_uuid4 ___________________

self = <tests.test_envelope_validation.TestMessageIdValidation object at 0x7fcff0951050>

    def test_valid_uuid4(self):
        """Test that valid UUID4 is accepted (approximating UUIDv7)."""
        message_id = str(uuid.uuid4())
        envelope_data = {
            "message_id": message_id,
            "ts": "2023-10-02T14:30:00Z",
            "sender": {"agent_id": "agent-001"},
            "recipient": {"agent_id": "agent-002"},
            "payload": {"action": "test"}
        }
    
        # Note: Our current implementation accepts UUID4 as approximation
        # In production, this would need proper UUIDv7 validation
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='4d03101e-c88e-4932-9744-851892850fc5', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:115: ValidationError
____________ TestTimestampValidation.test_valid_rfc3339_timestamps _____________

self = <tests.test_envelope_validation.TestTimestampValidation object at 0x7fcff0952490>

    def test_valid_rfc3339_timestamps(self):
        """Test that valid RFC3339 timestamps are accepted."""
        valid_timestamps = [
            "2023-10-02T14:30:00Z",
            "2023-10-02T14:30:00.123Z",
            "2023-10-02T14:30:00.123456Z",
            "2023-12-31T23:59:59Z"
        ]
    
        for ts in valid_timestamps:
            envelope_data = {
                "message_id": str(uuid.uuid4()),
                "ts": ts,
                "sender": {"agent_id": "agent-001"},
                "recipient": {"agent_id": "agent-002"},
                "payload": {"action": "test"}
            }
    
>           envelope = Envelope(**envelope_data)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^
E           pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E           message_id
E             Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='0280dc15-8a88-4447-b111-24d197d431e1', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:169: ValidationError
_____________________ TestTypeValidation.test_valid_types ______________________

self = <tests.test_envelope_validation.TestTypeValidation object at 0x7fcff0953310>

    def test_valid_types(self):
        """Test that all valid message types are accepted."""
        valid_types = ["message", "event", "command", "result", "error"]
    
        for msg_type in valid_types:
            envelope_data = {
                "message_id": str(uuid.uuid4()),
                "ts": "2023-10-02T14:30:00Z",
                "type": msg_type,
                "sender": {"agent_id": "agent-001"},
                "recipient": {"agent_id": "agent-002"},
                "payload": {"action": "test"}
            }
    
>           envelope = Envelope(**envelope_data)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^
E           pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E           message_id
E             Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='aaacf1ff-de04-4030-bb28-c2ba9d2034a5', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:216: ValidationError
__________ TestSenderRecipientValidation.test_valid_sender_recipient ___________

self = <tests.test_envelope_validation.TestSenderRecipientValidation object at 0x7fcff095c1d0>

    def test_valid_sender_recipient(self):
        """Test that valid sender/recipient are accepted."""
        envelope_data = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "sender": {"agent_id": "agent-001", "org_id": "org-123"},
            "recipient": {"agent_id": "agent-002", "org_id": "org-456"},
            "payload": {"action": "test"}
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='7578daf8-d61a-46eb-9937-9dc023779d68', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:250: ValidationError
___________ TestSenderRecipientValidation.test_sender_without_org_id ___________

self = <tests.test_envelope_validation.TestSenderRecipientValidation object at 0x7fcff095c7d0>

    def test_sender_without_org_id(self):
        """Test that sender without org_id is accepted."""
        envelope_data = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "sender": {"agent_id": "agent-001"},
            "recipient": {"agent_id": "agent-002"},
            "payload": {"action": "test"}
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='9ea8323b-e237-4920-930c-8114dd030a86', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:266: ValidationError
___________________ TestTtlValidation.test_valid_ttl_values ____________________

self = <tests.test_envelope_validation.TestTtlValidation object at 0x7fcff095dbd0>

    def test_valid_ttl_values(self):
        """Test that valid TTL values are accepted."""
        valid_ttls = [1, 1000, 30000, 60000, 120000]
    
        for ttl in valid_ttls:
            envelope_data = {
                "message_id": str(uuid.uuid4()),
                "ts": "2023-10-02T14:30:00Z",
                "sender": {"agent_id": "agent-001"},
                "recipient": {"agent_id": "agent-002"},
                "payload": {"action": "test"},
                "ttl_ms": ttl
            }
    
>           envelope = Envelope(**envelope_data)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^
E           pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E           message_id
E             Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='a6e3dae4-fe5f-4695-a1d5-b80cea87aa96', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:317: ValidationError
____________ TestExtraFieldsValidation.test_extra_fields_in_sender _____________

self = <tests.test_envelope_validation.TestExtraFieldsValidation object at 0x7fcff095f010>

    def test_extra_fields_in_sender(self):
        """Test that extra fields in sender are rejected."""
        envelope_data = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "sender": {
                "agent_id": "agent-001",
                "extra_field": "not_allowed"
            },
            "recipient": {"agent_id": "agent-002"},
            "payload": {"action": "test"}
        }
    
        with pytest.raises(ValidationError) as exc_info:
            Envelope(**envelope_data)
    
        errors = exc_info.value.errors()
>       assert any("extra_field" in str(error["loc"]) for error in errors)
E       assert False
E        +  where False = any(<generator object TestExtraFieldsValidation.test_extra_fields_in_sender.<locals>.<genexpr> at 0x7fcfee87e020>)

tests/test_envelope_validation.py:378: AssertionError
______________ TestMinifyFunction.test_minify_removes_none_values ______________

self = <tests.test_envelope_validation.TestMinifyFunction object at 0x7fcff0952610>

    def test_minify_removes_none_values(self):
        """Test that minify() removes None values."""
        envelope_data = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "sender": {"agent_id": "agent-001"},
            "recipient": {"agent_id": "agent-002"},
            "payload": {"action": "test"}
            # reply_to and nonce will be None by default
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='0c402f96-3980-45f3-98da-34528e3b6903', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:395: ValidationError
___________ TestMinifyFunction.test_minify_preserves_non_none_values ___________

self = <tests.test_envelope_validation.TestMinifyFunction object at 0x7fcff093fc50>

    def test_minify_preserves_non_none_values(self):
        """Test that minify() preserves non-None values."""
        envelope_data = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "sender": {"agent_id": "agent-001", "org_id": "org-123"},
            "recipient": {"agent_id": "agent-002"},
            "payload": {"action": "test"},
            "reply_to": "msg-reply-123"
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='c31d4538-5be9-4fc4-9e39-086fd595df5d', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:421: ValidationError
_______________ TestMinifyFunction.test_minify_nested_structures _______________

self = <tests.test_envelope_validation.TestMinifyFunction object at 0x7fcff095ee10>

    def test_minify_nested_structures(self):
        """Test that minify() handles nested None values."""
        envelope_data = {
            "message_id": str(uuid.uuid4()),
            "ts": "2023-10-02T14:30:00Z",
            "sender": {"agent_id": "agent-001"},
            "recipient": {"agent_id": "agent-002"},
            "payload": {
                "action": "test",
                "params": {
                    "key1": "value1",
                    "key2": None,
                    "key3": "value3"
                },
                "optional": None
            }
        }
    
>       envelope = Envelope(**envelope_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='8ba888a8-0842-4f22-a719-e22c46078290', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

tests/test_envelope_validation.py:450: ValidationError
________ TestCreateSampleEnvelope.test_create_sample_envelope_defaults _________

self = <tests.test_envelope_validation.TestCreateSampleEnvelope object at 0x7fcff095e610>

    def test_create_sample_envelope_defaults(self):
        """Test that create_sample_envelope creates valid envelope with defaults."""
>       envelope = create_sample_envelope()
                   ^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_envelope_validation.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sender_agent_id = 'agent-001', recipient_agent_id = 'agent-002'
payload = {'action': 'test', 'data': 'sample'}

    def create_sample_envelope(
        sender_agent_id: str = "agent-001",
        recipient_agent_id: str = "agent-002",
        payload: Optional[Dict[str, Any]] = None
    ) -> Envelope:
        """
        Create a sample envelope for testing purposes.
    
        Args:
            sender_agent_id: Sender agent ID
            recipient_agent_id: Recipient agent ID
            payload: Optional payload dict
    
        Returns:
            Valid Envelope instance
        """
        if payload is None:
            payload = {"action": "test", "data": "sample"}
    
        # Generate UUIDv7 (approximation using uuid4 for now)
        message_id = str(uuid.uuid4())
    
        # Current UTC timestamp in RFC3339 format
        timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ')[:-3] + 'Z'
    
>       return Envelope(
            message_id=message_id,
            ts=timestamp,
            sender=Sender(agent_id=sender_agent_id),
            recipient=Recipient(agent_id=recipient_agent_id),
            payload=payload
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='544bb421-c34c-439f-877e-cc0c861da1f1', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

src/schemas/envelope.py:225: ValidationError
______ TestCreateSampleEnvelope.test_create_sample_envelope_custom_params ______

self = <tests.test_envelope_validation.TestCreateSampleEnvelope object at 0x7fcff095d1d0>

    def test_create_sample_envelope_custom_params(self):
        """Test that create_sample_envelope accepts custom parameters."""
        custom_payload = {"custom": "data"}
>       envelope = create_sample_envelope(
            sender_agent_id="custom-sender",
            recipient_agent_id="custom-recipient",
            payload=custom_payload
        )

tests/test_envelope_validation.py:478: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sender_agent_id = 'custom-sender', recipient_agent_id = 'custom-recipient'
payload = {'custom': 'data'}

    def create_sample_envelope(
        sender_agent_id: str = "agent-001",
        recipient_agent_id: str = "agent-002",
        payload: Optional[Dict[str, Any]] = None
    ) -> Envelope:
        """
        Create a sample envelope for testing purposes.
    
        Args:
            sender_agent_id: Sender agent ID
            recipient_agent_id: Recipient agent ID
            payload: Optional payload dict
    
        Returns:
            Valid Envelope instance
        """
        if payload is None:
            payload = {"action": "test", "data": "sample"}
    
        # Generate UUIDv7 (approximation using uuid4 for now)
        message_id = str(uuid.uuid4())
    
        # Current UTC timestamp in RFC3339 format
        timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ')[:-3] + 'Z'
    
>       return Envelope(
            message_id=message_id,
            ts=timestamp,
            sender=Sender(agent_id=sender_agent_id),
            recipient=Recipient(agent_id=recipient_agent_id),
            payload=payload
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Envelope
E       message_id
E         Value error, message_id must be a valid UUIDv7 string: UUID must be version 7 (UUIDv7). Set BRIKK_ALLOW_UUID4=true to allow UUID4 for testing. [type=value_error, input_value='7c7f0fc8-a55a-4319-9d43-aef9ac0dd1a6', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

src/schemas/envelope.py:225: ValidationError
__________ TestHealthEndpoint.test_health_endpoint_always_returns_200 __________

self = <tests.test_health.TestHealthEndpoint object at 0x7fcff096a010>
client = <FlaskClient <Flask 'src.factory'>>

    def test_health_endpoint_always_returns_200(self, client):
        """Test that health endpoint always returns 200."""
        response = client.get('/healthz')
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_health.py:18: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:26.170746+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:26.170871+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
___________ TestHealthEndpoint.test_health_endpoint_response_format ____________

self = <tests.test_health.TestHealthEndpoint object at 0x7fcff096a690>
client = <FlaskClient <Flask 'src.factory'>>

    def test_health_endpoint_response_format(self, client):
        """Test health endpoint response format."""
        response = client.get('/healthz')
        data = response.get_json()
    
        # Check required fields
>       assert 'status' in data
               ^^^^^^^^^^^^^^^^
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_health.py:26: TypeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:26.266525+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:26.266649+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_____________ TestHealthEndpoint.test_health_endpoint_head_method ______________

self = <tests.test_health.TestHealthEndpoint object at 0x7fcff096ad10>
client = <FlaskClient <Flask 'src.factory'>>

    def test_health_endpoint_head_method(self, client):
        """Test health endpoint supports HEAD method."""
        response = client.head('/healthz')
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_health.py:42: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:26.362091+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:26.362212+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_____________ TestHealthEndpoint.test_health_endpoint_content_type _____________

self = <tests.test_health.TestHealthEndpoint object at 0x7fcff096b3d0>
client = <FlaskClient <Flask 'src.factory'>>

    def test_health_endpoint_content_type(self, client):
        """Test health endpoint content type."""
        response = client.get('/healthz')
>       assert response.content_type == 'application/json'
E       AssertionError: assert 'text/html; charset=utf-8' == 'application/json'
E         
E         - application/json
E         + text/html; charset=utf-8

tests/test_health.py:48: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:26.454452+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:26.454591+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
____ TestReadinessEndpoint.test_readiness_endpoint_all_dependencies_healthy ____

self = <tests.test_health.TestReadinessEndpoint object at 0x7fcff096bb50>
mock_redis = <MagicMock name='redis' id='140531028477776'>
client = <FlaskClient <Flask 'src.factory'>>

    @patch('src.services.rate_limit.redis')
    def test_readiness_endpoint_all_dependencies_healthy(self, mock_redis, client):
        """Test readiness endpoint when all dependencies are healthy."""
        # Mock Redis connection success
        mock_redis_instance = MagicMock()
        mock_redis_instance.ping.return_value = True
        mock_redis.return_value = mock_redis_instance
    
        response = client.get('/readyz')
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_health.py:63: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:26.547911+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:26.548031+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
________ TestReadinessEndpoint.test_readiness_endpoint_redis_unhealthy _________

self = <tests.test_health.TestReadinessEndpoint object at 0x7fcff096c190>
mock_redis = <MagicMock name='redis' id='140531027377616'>
client = <FlaskClient <Flask 'src.factory'>>

    @patch('src.services.rate_limit.redis')
    def test_readiness_endpoint_redis_unhealthy(self, mock_redis, client):
        """Test readiness endpoint when Redis is unhealthy."""
        # Mock Redis connection failure
        mock_redis_instance = MagicMock()
        mock_redis_instance.ping.side_effect = Exception("Connection failed")
        mock_redis.return_value = mock_redis_instance
    
        response = client.get('/readyz')
>       assert response.status_code == 503
E       assert 404 == 503
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_health.py:81: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:26.642009+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:26.642129+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_________ TestReadinessEndpoint.test_readiness_endpoint_redis_timeout __________

self = <tests.test_health.TestReadinessEndpoint object at 0x7fcff096c790>
mock_redis = <MagicMock name='redis' id='140531026058896'>
client = <FlaskClient <Flask 'src.factory'>>

    @patch('src.services.rate_limit.redis')
    def test_readiness_endpoint_redis_timeout(self, mock_redis, client):
        """Test readiness endpoint when Redis times out."""
        # Mock Redis timeout
        mock_redis_instance = MagicMock()
        mock_redis_instance.ping.side_effect = TimeoutError("Redis timeout")
        mock_redis.return_value = mock_redis_instance
    
        response = client.get('/readyz')
>       assert response.status_code == 503
E       assert 404 == 503
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_health.py:99: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:26.737006+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:26.737150+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
________ TestReadinessEndpoint.test_readiness_endpoint_response_format _________

self = <tests.test_health.TestReadinessEndpoint object at 0x7fcff096cdd0>
mock_redis = <MagicMock name='redis' id='140531029615824'>
client = <FlaskClient <Flask 'src.factory'>>

    @patch('src.services.rate_limit.redis')
    def test_readiness_endpoint_response_format(self, mock_redis, client):
        """Test readiness endpoint response format."""
        mock_redis_instance = MagicMock()
        mock_redis_instance.ping.return_value = True
        mock_redis.return_value = mock_redis_instance
        response = client.get('/readyz')
        data = response.get_json()
    
        # Check required fields
>       assert 'status' in data
               ^^^^^^^^^^^^^^^^
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_health.py:115: TypeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:26.831293+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:26.831410+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
__________ TestReadinessEndpoint.test_readiness_endpoint_head_method ___________

self = <tests.test_health.TestReadinessEndpoint object at 0x7fcff095ddd0>
client = <FlaskClient <Flask 'src.factory'>>

    def test_readiness_endpoint_head_method(self, client):
        """Test readiness endpoint supports HEAD method."""
        response = client.head('/readyz')
        # Status code depends on dependencies, but should be either 200 or 503
>       assert response.status_code in [200, 503]
E       assert 404 in [200, 503]
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_health.py:134: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:26.926575+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:26.926693+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
__________ TestReadinessEndpoint.test_readiness_endpoint_content_type __________

self = <tests.test_health.TestReadinessEndpoint object at 0x7fcff096c310>
client = <FlaskClient <Flask 'src.factory'>>

    def test_readiness_endpoint_content_type(self, client):
        """Test readiness endpoint content type."""
        response = client.get('/readyz')
>       assert response.content_type == 'application/json'
E       AssertionError: assert 'text/html; charset=utf-8' == 'application/json'
E         
E         - application/json
E         + text/html; charset=utf-8

tests/test_health.py:140: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:27.020306+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:27.020426+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
________ TestHealthVsReadiness.test_health_vs_readiness_when_redis_down ________

self = <tests.test_health.TestHealthVsReadiness object at 0x7fcff096d650>
mock_redis = <MagicMock name='redis' id='140531030393616'>
client = <FlaskClient <Flask 'src.factory'>>

    @patch('src.services.rate_limit.redis')
    def test_health_vs_readiness_when_redis_down(self, mock_redis, client):
        """Test that health is always OK but readiness fails when Redis is down."""
        # Mock Redis failure
        mock_redis_instance = MagicMock()
        mock_redis_instance.ping.side_effect = Exception("Redis down")
        mock_redis.return_value = mock_redis_instance
    
        # Health should always be OK
        health_response = client.get('/healthz')
>       assert health_response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_health.py:156: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:27.115803+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:27.115924+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
__________ TestHealthVsReadiness.test_health_has_no_dependency_checks __________

self = <tests.test_health.TestHealthVsReadiness object at 0x7fcff096da10>
client = <FlaskClient <Flask 'src.factory'>>

    def test_health_has_no_dependency_checks(self, client):
        """Test that health endpoint has no dependency checks."""
        response = client.get('/healthz')
        data = response.get_json()
    
        # Health should not have checks field
>       assert 'checks' not in data
               ^^^^^^^^^^^^^^^^^^^^
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_health.py:173: TypeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:27.211428+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:27.211560+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
__________ TestHealthVsReadiness.test_readiness_has_dependency_checks __________

self = <tests.test_health.TestHealthVsReadiness object at 0x7fcff096ddd0>
mock_redis = <MagicMock name='redis' id='140531024110864'>
client = <FlaskClient <Flask 'src.factory'>>

    @patch('src.services.rate_limit.redis')
    def test_readiness_has_dependency_checks(self, mock_redis, client):
        """Test that readiness endpoint has dependency checks."""
        mock_redis_instance = MagicMock()
        mock_redis_instance.ping.return_value = True
        mock_redis.return_value = mock_redis_instance
        response = client.get('/readyz')
        data = response.get_json()
    
        # Readiness should have checks field
>       assert 'checks' in data
               ^^^^^^^^^^^^^^^^
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_health.py:189: TypeError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:27.306476+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:27.306615+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
________ TestHealthEndpointIntegration.test_health_endpoints_registered ________

self = <tests.test_health.TestHealthEndpointIntegration object at 0x7fcff096e350>
app = <Flask 'src.factory'>

    def test_health_endpoints_registered(self, app):
        """Test that health endpoints are properly registered."""
        # Check that routes are registered
        routes = [rule.rule for rule in app.url_map.iter_rules()]
>       assert '/healthz' in routes
E       AssertionError: assert '/healthz' in ['/static/<path:filename>', '/metrics', '/api/auth/_ping', '/api/auth/_routes', '/api/auth/_debug-echo', '/api/auth/complete-signup', ...]

tests/test_health.py:203: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:27.537735+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:27.537865+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_________ TestHealthEndpointIntegration.test_health_endpoints_methods __________

self = <tests.test_health.TestHealthEndpointIntegration object at 0x7fcff096e950>
app = <Flask 'src.factory'>

    def test_health_endpoints_methods(self, app):
        """Test that health endpoints support correct HTTP methods."""
        # Find health endpoint rules
        health_rule = None
        readiness_rule = None
    
        for rule in app.url_map.iter_rules():
            if rule.rule == '/healthz':
                health_rule = rule
            elif rule.rule == '/readyz':
                readiness_rule = rule
    
>       assert health_rule is not None
E       assert None is not None

tests/test_health.py:218: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:27.632333+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:27.632470+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_____ TestHealthEndpointIntegration.test_health_endpoints_no_auth_required _____

self = <tests.test_health.TestHealthEndpointIntegration object at 0x7fcff096efd0>
client = <FlaskClient <Flask 'src.factory'>>

    def test_health_endpoints_no_auth_required(self, client):
        """Test that health endpoints don't require authentication."""
        # Health endpoints should work without any authentication
        health_response = client.get('/healthz')
>       assert health_response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_health.py:231: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:27.727668+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:27.727792+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_______ TestHealthEndpointPerformance.test_health_endpoint_fast_response _______

self = <tests.test_health.TestHealthEndpointPerformance object at 0x7fcff096f890>
client = <FlaskClient <Flask 'src.factory'>>

    def test_health_endpoint_fast_response(self, client):
        """Test that health endpoint responds quickly."""
        start_time = time.time()
        response = client.get('/healthz')
        end_time = time.time()
    
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_health.py:247: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:27.823478+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:27.823604+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_ TestHealthEndpointPerformance.test_readiness_endpoint_reasonable_response_time _

self = <tests.test_health.TestHealthEndpointPerformance object at 0x7fcff096fe90>
mock_redis = <MagicMock name='redis' id='140531027756880'>
client = <FlaskClient <Flask 'src.factory'>>

    @patch('src.services.rate_limit.redis')
    def test_readiness_endpoint_reasonable_response_time(self, mock_redis, client):
        """Test that readiness endpoint responds in reasonable time."""
        # Mock Redis with small delay
        mock_redis_instance = MagicMock()
        mock_redis_instance.ping.return_value = True
        mock_redis.return_value = mock_redis_instance
    
        start_time = time.time()
        response = client.get('/readyz')
        end_time = time.time()
    
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_health.py:265: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:27.920337+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:27.920475+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
___ TestHealthEndpointPerformance.test_health_endpoints_concurrent_requests ____

self = <tests.test_health.TestHealthEndpointPerformance object at 0x7fcff097c550>
client = <FlaskClient <Flask 'src.factory'>>

    def test_health_endpoints_concurrent_requests(self, client):
        """Test that health endpoints handle concurrent requests."""
        import threading
        import queue
    
        results = queue.Queue()
    
        def make_request():
            try:
                response = client.get('/healthz')
                results.put(response.status_code)
            except Exception as e:
                results.put(str(e))
    
        # Start multiple concurrent requests
        threads = []
        for _ in range(10):
            thread = threading.Thread(target=make_request)
            threads.append(thread)
            thread.start()
    
        # Wait for all threads to complete
        for thread in threads:
            thread.join()
    
        # Check that all requests succeeded
        status_codes = []
        while not results.empty():
            status_codes.append(results.get())
    
        assert len(status_codes) == 10
>       assert all(code == 200 for code in status_codes)
E       assert False
E        +  where False = all(<generator object TestHealthEndpointPerformance.test_health_endpoints_concurrent_requests.<locals>.<genexpr> at 0x7fcfedce2810>)

tests/test_health.py:302: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:28.015451+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:28.015581+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
__ TestHealthEndpointErrorHandling.test_readiness_handles_redis_import_error ___

self = <tests.test_health.TestHealthEndpointErrorHandling object at 0x7fcff097cdd0>
mock_redis = <MagicMock name='redis' id='140531063067728'>
client = <FlaskClient <Flask 'src.factory'>>

    @patch('src.services.rate_limit.redis')
    def test_readiness_handles_redis_import_error(self, mock_redis, client):
        """Test readiness endpoint handles Redis import errors gracefully."""
        # Mock Redis import failure
        mock_redis.side_effect = ImportError("Redis not available")
    
        response = client.get('/readyz')
>       assert response.status_code == 503
E       assert 404 == 503
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_health.py:315: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:28.118130+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:28.118244+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_ TestHealthEndpointErrorHandling.test_readiness_handles_unexpected_redis_errors _

self = <tests.test_health.TestHealthEndpointErrorHandling object at 0x7fcff097d3d0>
mock_redis = <MagicMock name='redis' id='140531035660624'>
client = <FlaskClient <Flask 'src.factory'>>

    @patch('src.services.rate_limit.redis')
    def test_readiness_handles_unexpected_redis_errors(self, mock_redis, client):
        """Test readiness endpoint handles unexpected Redis errors."""
        # Mock unexpected Redis error
        mock_redis_instance = MagicMock()
        mock_redis_instance.ping.side_effect = RuntimeError("Unexpected error")
        mock_redis.return_value = mock_redis_instance
    
        response = client.get('/readyz')
>       assert response.status_code == 503
E       assert 404 == 503
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_health.py:330: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:28.213427+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:28.213549+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
______ TestHealthEndpointErrorHandling.test_health_endpoint_always_works _______

self = <tests.test_health.TestHealthEndpointErrorHandling object at 0x7fcff097da50>
client = <FlaskClient <Flask 'src.factory'>>

    def test_health_endpoint_always_works(self, client):
        """Test that health endpoint works even if other systems fail."""
        # Health should always work regardless of other system states
        response = client.get('/healthz')
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_health.py:340: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:28.306397+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:28.306507+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
_____________________________ test_create_webhook ______________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'organization_id': '5f845ca4-3bb5-476e-8c0e-07ae5daaeea8'}

    def test_create_webhook(client: FlaskClient, auth_headers: dict):
        """Test creating a new webhook subscription"""
        webhook_data = {
            "url": "https://example.com/webhook",
            "secret": "supersecret",
            "events": ["agent.created", "coordination.completed"]
        }
    
        response = client.post("/api/v1/webhooks", json=webhook_data, headers=auth_headers)
>       assert response.status_code == 201
E       assert 422 == 201
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_integrations_v1.py:58: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:28.397636+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:28.397732+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:28.582225+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/webhooks", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 118}
{"timestamp": "2025-10-13T03:37:28.582838+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/webhooks - 422 (0.39ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "955bff16-dcc6-41ef-8338-f22918c788e7", "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.39, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/webhooks
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/webhooks - 422 (0.39ms)
______________________________ test_get_webhooks _______________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'organization_id': '0d7550da-9ccf-4cf7-9897-cb1ec154c5e5'}

    def test_get_webhooks(client: FlaskClient, auth_headers: dict):
        """Test getting all webhooks for an organization"""
        # First, create a webhook
        client.post("/api/v1/webhooks", json={
            "url": "https://example.com/webhook",
            "secret": "supersecret",
            "events": ["agent.created"]
        }, headers=auth_headers)
    
        response = client.get("/api/v1/webhooks", headers=auth_headers)
>       assert response.status_code == 200
E       assert 422 == 200
E        +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_integrations_v1.py:71: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:28.605023+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:28.605129+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:28.793290+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/webhooks", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 92}
{"timestamp": "2025-10-13T03:37:28.793911+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/webhooks - 422 (0.39ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "8276e51c-823b-405d-9fd3-53844dba80e2", "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.39, "event_type": "request_end", "status_code": 422, "content_length": 30}
{"timestamp": "2025-10-13T03:37:28.794486+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/v1/webhooks", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "8276e51c-823b-405d-9fd3-53844dba80e2", "method": "GET", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 1.03, "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:37:28.794897+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/v1/webhooks - 422 (0.27ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "644dfdae-3bdd-46ab-83f0-08218f16d717", "method": "GET", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.27, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/webhooks
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/webhooks - 422 (0.39ms)
INFO     brikk.requests:structured_logging.py:85 Request started: GET /api/v1/webhooks
INFO     brikk.requests:structured_logging.py:85 Request completed: GET /api/v1/webhooks - 422 (0.27ms)
_____________________________ test_update_webhook ______________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'organization_id': '3dda6f42-b450-44d6-8b58-c782bd562fbb'}

    def test_update_webhook(client: FlaskClient, auth_headers: dict):
        """Test updating a webhook"""
        create_response = client.post("/api/v1/webhooks", json={
            "url": "https://example.com/webhook",
            "secret": "supersecret",
            "events": ["agent.created"]
        }, headers=auth_headers)
>       webhook_id = create_response.json["id"]
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_integrations_v1.py:81: KeyError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:28.816469+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:28.816569+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:29.004099+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/webhooks", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 92}
{"timestamp": "2025-10-13T03:37:29.004680+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/webhooks - 422 (0.36ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "2f25f09c-955e-4479-9cb4-a2d48da5ef1c", "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.36, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/webhooks
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/webhooks - 422 (0.36ms)
_____________________________ test_delete_webhook ______________________________

client = <FlaskClient <Flask 'src.factory'>>
auth_headers = {'Authorization': 'Bearer dummy_token', 'organization_id': 'f5a87970-532f-468a-b0da-7a2ef8fbd05a'}

    def test_delete_webhook(client: FlaskClient, auth_headers: dict):
        """Test deleting a webhook"""
        create_response = client.post("/api/v1/webhooks", json={
            "url": "https://example.com/webhook",
            "secret": "supersecret",
            "events": ["agent.created"]
        }, headers=auth_headers)
>       webhook_id = create_response.json["id"]
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_integrations_v1.py:97: KeyError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:29.025552+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:29.025657+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:29.210479+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/webhooks", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 92}
{"timestamp": "2025-10-13T03:37:29.211103+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/webhooks - 422 (0.4ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "0210b313-a67e-4e56-b67f-2ee4fe650afe", "method": "POST", "path": "/api/v1/webhooks", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.4, "event_type": "request_end", "status_code": 422, "content_length": 30}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/webhooks
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/webhooks - 422 (0.4ms)
__________________________ test_webhook_event_trigger __________________________

mock_post = <MagicMock name='post' id='140531013304720'>
app = <Flask 'src.factory'>
auth_headers = {'Authorization': 'Bearer dummy_token', 'organization_id': 'b1d29130-8fc0-4e02-8e4b-7250fa9444cb'}

    @patch("requests.post")
    def test_webhook_event_trigger(mock_post, app: Flask, auth_headers: dict):
        """Test triggering a webhook event"""
        mock_post.return_value.status_code = 200
    
        with app.app_context():
            db_session = db.session
            webhook_service = WebhookService(db_session)
    
            # Create a webhook
            webhook = webhook_service.create_webhook(
                organization_id=auth_headers["organization_id"],
                url="https://example.com/webhook",
                secret="secret",
                events=["test.event"]
            )
    
            # Trigger an event
            webhook_service.trigger_event(
                event_type="test.event",
                payload_data={"key": "value"},
                organization_id=auth_headers["organization_id"]
            )
    
            # Verify that requests.post was called
            mock_post.assert_called_once()
            call_args = mock_post.call_args
>           assert call_args.kwargs["url"] == webhook.url
                   ^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'url'

tests/test_integrations_v1.py:132: KeyError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:29.232951+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:29.233057+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:29.427099+00:00", "level": "INFO", "logger": "brikk.webhooks", "message": "Created webhook 1 for organization b1d29130-8fc0-4e02-8e4b-7250fa9444cb", "module": "structured_logging", "function": "_log_with_context", "line": 85}
{"timestamp": "2025-10-13T03:37:29.435559+00:00", "level": "ERROR", "logger": "brikk.webhooks", "message": "Failed to send webhook event 1: (sqlite3.ProgrammingError) Error binding parameter 3: type 'MagicMock' is not supported\n[SQL: UPDATE webhook_events SET status=?, response_status_code=?, response_body=?, updated_at=CURRENT_TIMESTAMP WHERE webhook_events.id = ?]\n[parameters: ('success', 200, <MagicMock name='post().text' id='140531030716560'>, 1)]\n(Background on this error at: https://sqlalche.me/e/20/f405)", "module": "structured_logging", "function": "_log_with_context", "line": 85}
{"timestamp": "2025-10-13T03:37:29.436363+00:00", "level": "ERROR", "logger": "brikk.webhooks", "message": "Failed to create webhook event for webhook 1: This Session's transaction has been rolled back due to a previous exception during flush. To begin a new transaction with this Session, first issue Session.rollback(). Original exception was: (sqlite3.ProgrammingError) Error binding parameter 3: type 'MagicMock' is not supported\n[SQL: UPDATE webhook_events SET status=?, response_status_code=?, response_body=?, updated_at=CURRENT_TIMESTAMP WHERE webhook_events.id = ?]\n[parameters: ('success', 200, <MagicMock name='post().text' id='140531030716560'>, 1)]\n(Background on this error at: https://sqlalche.me/e/20/f405) (Background on this error at: https://sqlalche.me/e/20/7s2a)", "module": "structured_logging", "function": "_log_with_context", "line": 85}
------------------------------ Captured log call -------------------------------
INFO     brikk.webhooks:structured_logging.py:85 Created webhook 1 for organization b1d29130-8fc0-4e02-8e4b-7250fa9444cb
ERROR    brikk.webhooks:structured_logging.py:85 Failed to send webhook event 1: (sqlite3.ProgrammingError) Error binding parameter 3: type 'MagicMock' is not supported
[SQL: UPDATE webhook_events SET status=?, response_status_code=?, response_body=?, updated_at=CURRENT_TIMESTAMP WHERE webhook_events.id = ?]
[parameters: ('success', 200, <MagicMock name='post().text' id='140531030716560'>, 1)]
(Background on this error at: https://sqlalche.me/e/20/f405)
ERROR    brikk.webhooks:structured_logging.py:85 Failed to create webhook event for webhook 1: This Session's transaction has been rolled back due to a previous exception during flush. To begin a new transaction with this Session, first issue Session.rollback(). Original exception was: (sqlite3.ProgrammingError) Error binding parameter 3: type 'MagicMock' is not supported
[SQL: UPDATE webhook_events SET status=?, response_status_code=?, response_body=?, updated_at=CURRENT_TIMESTAMP WHERE webhook_events.id = ?]
[parameters: ('success', 200, <MagicMock name='post().text' id='140531030716560'>, 1)]
(Background on this error at: https://sqlalche.me/e/20/f405) (Background on this error at: https://sqlalche.me/e/20/7s2a)
__________ TestRequestContextMiddleware.test_auth_context_integration __________

self = <tests.test_logging_context.TestRequestContextMiddleware object at 0x7fcff09aa750>
app = <Flask 'tests.test_logging_context'>

    def test_auth_context_integration(self, app):
        """Test that auth context is included in request context."""
        init_request_context(app)
    
        @app.route('/test')
        def test_route():
            # Set auth context
            set_auth_context({
                'org_id': 'test-org',
                'key_id': 'test-key',
                'agent_id': 'test-agent'
            })
    
            context = get_request_context()
            return context
    
        client = app.test_client()
        response = client.get('/test')
        assert response.status_code == 200
    
        context = response.get_json()
        assert 'organization_id' in context
>       assert 'api_key_id' in context
E       AssertionError: assert 'api_key_id' in {'duration_ms': 0.03, 'method': 'GET', 'organization_id': {'agent_id': 'test-agent', 'key_id': 'test-key', 'org_id': 'test-org'}, 'path': '/test', ...}

tests/test_logging_context.py:175: AssertionError
______________ TestStructuredFormatter.test_exception_formatting _______________

self = <tests.test_logging_context.TestStructuredFormatter object at 0x7fcff09ab490>

    def test_exception_formatting(self):
        """Test exception formatting in JSON logs."""
        formatter = StructuredFormatter(json_enabled=True)
    
        try:
            raise ValueError("Test exception")
        except ValueError:
            record = logging.LogRecord(
                name='test.logger',
                level=logging.ERROR,
                pathname='test.py',
                lineno=42,
                msg='Error occurred',
                args=(),
                exc_info=True
            )
    
>       formatted = formatter.format(record)
                    ^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_logging_context.py:294: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/services/structured_logging.py:60: in format
    log_entry['exception'] = self.formatException(record.exc_info)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.services.structured_logging.StructuredFormatter object at 0x7fcfed245110>
ei = True

    def formatException(self, ei):
        """
        Format and return the specified exception information as a string.
    
        This default implementation just uses
        traceback.print_exception()
        """
        sio = io.StringIO()
>       tb = ei[2]
             ^^^^^
E       TypeError: 'bool' object is not subscriptable

/usr/lib/python3.11/logging/__init__.py:641: TypeError
________ TestRateLimitIntegration.test_coordination_rate_limit_disabled ________

self = <tests.test_rate_limit.TestRateLimitIntegration object at 0x7fcff055f110>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    def test_coordination_rate_limit_disabled(self, client, valid_envelope):
        """Test coordination endpoint with rate limiting disabled."""
        with patch.dict(os.environ, {
            'BRIKK_RLIMIT_ENABLED': 'false',
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
>           assert response.status_code == 202
E           assert 422 == 202
E            +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_rate_limit.py:284: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:29.727361+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:29.727453+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:29.792215+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:37:29.793230+00:00", "level": "ERROR", "logger": "src.services.rate_limit", "message": "Failed to connect to Redis: Error 111 connecting to localhost:6379. Connection refused.", "module": "rate_limit", "function": "_create_redis_client", "line": 94, "request_id": "86d0ff77-ad67-4fe2-9cf0-d77802040528", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.84}
{"timestamp": "2025-10-13T03:37:29.793765+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (1.31ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "86d0ff77-ad67-4fe2-9cf0-d77802040528", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 1.31, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
ERROR    src.services.rate_limit:rate_limit.py:94 Failed to connect to Redis: Error 111 connecting to localhost:6379. Connection refused.
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (1.31ms)
________ TestRateLimitIntegration.test_coordination_rate_limit_allowed _________

self = <tests.test_rate_limit.TestRateLimitIntegration object at 0x7fcff055f850>
mock_redis_factory = <MagicMock name='_create_redis_client' id='140531028709904'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    @patch('src.services.rate_limit.RateLimitService._create_redis_client')
    def test_coordination_rate_limit_allowed(self, mock_redis_factory, client, valid_envelope):
        """Test coordination endpoint with rate limiting enabled and request allowed."""
        # Mock Redis client
        mock_redis = MagicMock()
        mock_redis.ping.return_value = True
        mock_pipeline = MagicMock()
        mock_pipeline.execute.return_value = [0, 1, 5, True]  # 5 requests in window
        mock_redis.pipeline.return_value = mock_pipeline
        mock_redis_factory.return_value = mock_redis
    
        with patch.dict(os.environ, {
            'BRIKK_RLIMIT_ENABLED': 'true',
            'BRIKK_RLIMIT_PER_MIN': '60',
            'BRIKK_RLIMIT_BURST': '20',
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
>           assert response.status_code == 202
E           assert 422 == 202
E            +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_rate_limit.py:315: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:29.802679+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:29.802769+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:29.830230+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:37:29.832505+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (2.05ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "edf6aa1b-cac7-4aad-a52a-c11f694204b8", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 2.05, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (2.05ms)
________ TestRateLimitIntegration.test_coordination_rate_limit_exceeded ________

self = <tests.test_rate_limit.TestRateLimitIntegration object at 0x7fcff054ef90>
mock_redis_factory = <MagicMock name='_create_redis_client' id='140531036672976'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    @patch('src.services.rate_limit.RateLimitService._create_redis_client')
    def test_coordination_rate_limit_exceeded(self, mock_redis_factory, client, valid_envelope):
        """Test coordination endpoint with rate limit exceeded."""
        # Mock Redis client to return count above limit
        mock_redis = MagicMock()
        mock_redis.ping.return_value = True
        mock_pipeline = MagicMock()
        mock_pipeline.execute.return_value = [0, 1, 85, True]  # 85 requests (above 80 limit)
        mock_redis.pipeline.return_value = mock_pipeline
        mock_redis.zrange.return_value = [('1640995140.123', 1640995140.123)]
        mock_redis_factory.return_value = mock_redis
    
        with patch.dict(os.environ, {
            'BRIKK_RLIMIT_ENABLED': 'true',
            'BRIKK_RLIMIT_PER_MIN': '60',
            'BRIKK_RLIMIT_BURST': '20',
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
>           assert response.status_code == 429
E           assert 500 == 429
E            +  where 500 = <WrapperTestResponse streamed [500 INTERNAL SERVER ERROR]>.status_code

tests/test_rate_limit.py:350: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:29.840971+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:29.841058+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stdout call -----------------------------
Coordination endpoint error: 'MetricsService' object has no attribute 'record_rate_limit_hit'
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:29.868666+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:37:29.870673+00:00", "level": "WARNING", "logger": "brikk.rate_limit", "message": "Rate limit exceeded for scope: None", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "98d37182-4d85-4ccb-903c-6e53c3f075d1", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 1.85, "event_type": "rate_limit", "scope": null, "limit_exceeded": true, "limit": 80, "remaining": 0}
Traceback (most recent call last):
  File "/home/ubuntu/brikk-infrastructure/src/routes/coordination.py", line 199, in coordination_endpoint
    get_metrics_service().record_rate_limit_hit(scope)
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'MetricsService' object has no attribute 'record_rate_limit_hit'
{"timestamp": "2025-10-13T03:37:29.871225+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 500 (2.34ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "e0504576-9c07-4f72-8bd6-fca836c380b9", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 2.34, "event_type": "request_end", "status_code": 500, "content_length": 119}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
WARNING  brikk.rate_limit:structured_logging.py:85 Rate limit exceeded for scope: None
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 500 (2.34ms)
_____ TestRateLimitIntegration.test_coordination_rate_limit_burst_behavior _____

self = <tests.test_rate_limit.TestRateLimitIntegration object at 0x7fcff055ea90>
mock_redis_factory = <MagicMock name='_create_redis_client' id='140531033067600'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    @patch('src.services.rate_limit.RateLimitService._create_redis_client')
    def test_coordination_rate_limit_burst_behavior(self, mock_redis_factory, client, valid_envelope):
        """Test burst capacity behavior."""
        mock_redis = MagicMock()
        mock_redis.ping.return_value = True
        mock_redis_factory.return_value = mock_redis
    
        with patch.dict(os.environ, {
            'BRIKK_RLIMIT_ENABLED': 'true',
            'BRIKK_RLIMIT_PER_MIN': '10',  # Low base limit
            'BRIKK_RLIMIT_BURST': '5',     # Small burst
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            # Test requests within burst capacity (total limit = 15)
            for count in [5, 10, 14]:  # Within limit
                mock_pipeline = MagicMock()
                mock_pipeline.execute.return_value = [0, 1, count, True]
                mock_redis.pipeline.return_value = mock_pipeline
    
                response = client.post(
                    '/api/v1/coordination',
                    data=json.dumps(valid_envelope),
                    headers={'Content-Type': 'application/json'}
                )
    
>               assert response.status_code == 202
E               assert 422 == 202
E                +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_rate_limit.py:392: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:29.879631+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:29.879719+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:29.906880+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:37:29.909124+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (1.99ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "04b975c7-b505-464a-99fe-e91f160b7908", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 1.99, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (1.99ms)
____ TestRateLimitIntegration.test_coordination_rate_limit_scope_switching _____

self = <tests.test_rate_limit.TestRateLimitIntegration object at 0x7fcff055fe90>
mock_redis_factory = <MagicMock name='_create_redis_client' id='140531023688592'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    @patch('src.services.rate_limit.RateLimitService._create_redis_client')
    def test_coordination_rate_limit_scope_switching(self, mock_redis_factory, client, valid_envelope):
        """Test rate limiting with different scoping configurations."""
        mock_redis = MagicMock()
        mock_redis.ping.return_value = True
        mock_pipeline = MagicMock()
        mock_pipeline.execute.return_value = [0, 1, 5, True]
        mock_redis.pipeline.return_value = mock_pipeline
        mock_redis_factory.return_value = mock_redis
    
        # Test organization scoping
        with patch.dict(os.environ, {
            'BRIKK_RLIMIT_ENABLED': 'true',
            'BRIKK_RLIMIT_SCOPE': 'org',
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
>           assert response.status_code == 202
E           assert 422 == 202
E            +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_rate_limit.py:432: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:29.918165+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:29.918255+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:29.945050+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:37:29.947288+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (2.01ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "57d318a8-4201-4595-b616-8c5f496a338a", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 2.01, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (2.01ms)
_____ TestRateLimitIntegration.test_coordination_rate_limit_redis_failure ______

self = <tests.test_rate_limit.TestRateLimitIntegration object at 0x7fcff05642d0>
mock_redis_factory = <MagicMock name='_create_redis_client' id='140531026255696'>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    @patch('src.services.rate_limit.RateLimitService._create_redis_client')
    def test_coordination_rate_limit_redis_failure(self, mock_redis_factory, client, valid_envelope):
        """Test graceful degradation when Redis fails."""
        # Mock Redis to raise exception
        mock_redis = MagicMock()
        mock_redis.ping.return_value = True
        mock_redis.pipeline.side_effect = Exception("Redis connection failed")
        mock_redis_factory.return_value = mock_redis
    
        with patch.dict(os.environ, {
            'BRIKK_RLIMIT_ENABLED': 'true',
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'false'
        }):
            response = client.post(
                '/api/v1/coordination',
                data=json.dumps(valid_envelope),
                headers={'Content-Type': 'application/json'}
            )
    
            # Should succeed despite Redis failure (graceful degradation)
>           assert response.status_code == 202
E           assert 422 == 202
E            +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_rate_limit.py:483: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:29.956587+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:29.956675+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:29.983178+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:37:29.983674+00:00", "level": "ERROR", "logger": "src.services.rate_limit", "message": "Rate limit check failed for rlimit:anonymous: Redis connection failed", "module": "rate_limit", "function": "check_rate_limit", "line": 190, "request_id": "e756ff3a-fa9a-41ee-82ce-42f4617921a7", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.33}
{"timestamp": "2025-10-13T03:37:29.984081+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (0.68ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "e756ff3a-fa9a-41ee-82ce-42f4617921a7", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.68, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
ERROR    src.services.rate_limit:rate_limit.py:190 Rate limit check failed for rlimit:anonymous: Redis connection failed
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (0.68ms)
____ TestRateLimitIntegration.test_coordination_rate_limit_with_idempotency ____

self = <tests.test_rate_limit.TestRateLimitIntegration object at 0x7fcff0564710>
client = <FlaskClient <Flask 'src.factory'>>
valid_envelope = {'message_id': '01234567-89ab-cdef-0123-456789abcdef', 'payload': {'test': 'data'}, 'recipient': {'agent_id': 'target-agent'}, 'sender': {'agent_id': 'test-agent'}, ...}

    def test_coordination_rate_limit_with_idempotency(self, client, valid_envelope):
        """Test rate limiting works alongside idempotency."""
        with patch.dict(os.environ, {
            'BRIKK_RLIMIT_ENABLED': 'true',
            'BRIKK_FEATURE_PER_ORG_KEYS': 'false',
            'BRIKK_IDEM_ENABLED': 'true'
        }):
            # Mock rate limiter to allow request
            with patch('src.services.rate_limit.get_rate_limiter') as mock_get_limiter:
                mock_limiter = MagicMock()
                mock_limiter.check_rate_limit.return_value = RateLimitResult(
                    allowed=True, limit=80, remaining=75, reset_time=1640995200
                )
                mock_get_limiter.return_value = mock_limiter
    
                response = client.post(
                    '/api/v1/coordination',
                    data=json.dumps(valid_envelope),
                    headers={'Content-Type': 'application/json'}
                )
    
>               assert response.status_code == 202
E               assert 422 == 202
E                +  where 422 = <WrapperTestResponse streamed [422 UNPROCESSABLE ENTITY]>.status_code

tests/test_rate_limit.py:511: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:29.992970+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:29.993059+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stdout call -----------------------------
Idempotency check error: 'NoneType' object has no attribute 'get'
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:30.019282+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: POST /api/v1/coordination", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": 260}
{"timestamp": "2025-10-13T03:37:30.020467+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: POST /api/v1/coordination - 422 (0.94ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "ca0d16cc-b25a-4813-938a-e370de6b919f", "method": "POST", "path": "/api/v1/coordination", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.94, "event_type": "request_end", "status_code": 422, "content_length": 401}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: POST /api/v1/coordination
INFO     brikk.requests:structured_logging.py:85 Request completed: POST /api/v1/coordination - 422 (0.94ms)
__________ TestBodySizeValidation.test_invalid_content_length_header ___________

self = <tests.test_request_guards.TestBodySizeValidation object at 0x7fcff0577090>
client = <FlaskClient <Flask 'tests.test_request_guards'>>

    def test_invalid_content_length_header(self, client):
        """Test that invalid Content-Length header is rejected with 400."""
        response = client.post(
            '/test',
            headers={
                'Content-Type': 'application/json',
                'Content-Length': 'invalid',
                'X-Brikk-Key': 'test-key',
                'X-Brikk-Timestamp': '1234567890',
                'X-Brikk-Signature': 'test-signature'
            },
            json={"test": "data"}
        )
>       assert response.status_code == 400
E       assert 200 == 400
E        +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_request_guards.py:201: AssertionError
______________________________ test_ping_endpoint ______________________________

client = <FlaskClient <Flask 'src.factory'>>

    def test_ping_endpoint(client):
        """Test that the ping endpoint returns a valid response."""
        response = client.get('/api/inbound/_ping')
        # Accept 200 OK or 302 redirect as valid responses
>       assert response.status_code in [200, 302]
E       assert 404 in [200, 302]
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_smoke.py:32: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:30.104436+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:30.104541+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:30.129736+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/inbound/_ping", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "GET", "path": "/api/inbound/_ping", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:37:30.130240+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/inbound/_ping - 404 (0.28ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "f4be558c-c4ac-4ff1-9047-97d711172721", "method": "GET", "path": "/api/inbound/_ping", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.28, "event_type": "request_end", "status_code": 404, "content_length": 207}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: GET /api/inbound/_ping
INFO     brikk.requests:structured_logging.py:85 Request completed: GET /api/inbound/_ping - 404 (0.28ms)
___________________________ test_basic_routes_exist ____________________________

client = <FlaskClient <Flask 'src.factory'>>

    def test_basic_routes_exist(client):
        """Test that basic application routes are accessible (don't return 404)."""
        # Test ping endpoint specifically
        response = client.get('/api/inbound/_ping')
>       assert response.status_code != 404
E       assert 404 != 404
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_smoke.py:53: AssertionError
---------------------------- Captured stderr setup -----------------------------
{"timestamp": "2025-10-13T03:37:30.161000+00:00", "level": "INFO", "logger": "brikk.config", "message": "Logging configured", "module": "structured_logging", "function": "_log_with_context", "line": 85, "json_enabled": true, "log_level": "INFO", "loggers_configured": ["brikk.coordination", "brikk.auth", "brikk.rate_limit", "brikk.idempotency", "brikk.metrics", "brikk.security"]}
{"timestamp": "2025-10-13T03:37:30.161103+00:00", "level": "INFO", "logger": "brikk.startup", "message": "Application starting", "module": "structured_logging", "function": "_log_with_context", "line": 85, "flask_env": null, "debug": false, "testing": false}
----------------------------- Captured stderr call -----------------------------
{"timestamp": "2025-10-13T03:37:30.187429+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request started: GET /api/inbound/_ping", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": null, "method": "GET", "path": "/api/inbound/_ping", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "event_type": "request_start", "content_length": null}
{"timestamp": "2025-10-13T03:37:30.187931+00:00", "level": "INFO", "logger": "brikk.requests", "message": "Request completed: GET /api/inbound/_ping - 404 (0.27ms)", "module": "structured_logging", "function": "_log_with_context", "line": 85, "request_id": "8199abdc-ebb1-4f63-b311-25c99d55cf3a", "method": "GET", "path": "/api/inbound/_ping", "remote_addr": "127.0.0.1", "user_agent": "Werkzeug/3.1.3", "duration_ms": 0.27, "event_type": "request_end", "status_code": 404, "content_length": 207}
------------------------------ Captured log call -------------------------------
INFO     brikk.requests:structured_logging.py:85 Request started: GET /api/inbound/_ping
INFO     brikk.requests:structured_logging.py:85 Request completed: GET /api/inbound/_ping - 404 (0.27ms)
=============================== warnings summary ===============================
tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_feature_disabled
  /home/ubuntu/brikk-infrastructure/src/schemas/auth.py:19: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    @validator('slug')

tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_feature_disabled
  /home/ubuntu/brikk-infrastructure/src/schemas/auth.py:26: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    @validator('contact_email')

tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_feature_disabled
  /home/ubuntu/brikk-infrastructure/src/schemas/auth.py:43: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    @validator('agent_id')

tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_feature_disabled
  /home/ubuntu/brikk-infrastructure/src/schemas/auth.py:61: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    @validator('scopes')

tests/test_integrations_v1.py::test_webhook_event_trigger
  /home/ubuntu/brikk-infrastructure/src/services/webhook_service.py:156: SAWarning: Session's state has been changed on a non-active transaction - this state will be discarded.
    self.db.rollback()

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/auth/test_api_key_rotation.py::TestApiKeyRotation::test_api_key_creation
FAILED tests/auth/test_api_key_rotation.py::TestApiKeyRotation::test_api_key_rotation
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_feature_disabled
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_missing_headers
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_invalid_timestamp
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_authenticate_request_invalid_api_key
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_check_idempotency_feature_disabled
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_check_idempotency_no_auth
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_check_idempotency_success
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_check_idempotency_replay
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_set_auth_context
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_log_auth_result_success
FAILED tests/auth/test_hmac_auth.py::TestAuthMiddleware::test_log_auth_result_failure
FAILED tests/auth/test_idempotency.py::TestIdempotencyService::test_process_request_idempotency_with_custom_key
FAILED tests/test_basic.py::test_health_endpoint - assert 404 == 200
FAILED tests/test_basic.py::test_inbound_ping_endpoint - assert 404 == 200
FAILED tests/test_billing_portal_stripe13.py::test_billing_portal_request_validation
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_flags_off
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_valid_hmac
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_missing_headers
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_invalid_api_key
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_invalid_signature
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_timestamp_drift
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_idempotent_replay
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_idempotency_conflict
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_health_endpoint
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_security_headers_present
FAILED tests/test_coordination_auth.py::TestCoordinationAuth::test_coordination_endpoint_with_custom_idempotency_key
FAILED tests/test_coordination_stub.py::TestCoordinationEndpoint::test_valid_request_returns_202
FAILED tests/test_coordination_stub.py::TestCoordinationEndpoint::test_minimal_valid_envelope
FAILED tests/test_coordination_stub.py::TestCoordinationEndpoint::test_security_headers_present
FAILED tests/test_coordination_stub.py::TestRequestGuardsIntegration::test_missing_content_type_returns_415
FAILED tests/test_coordination_stub.py::TestRequestGuardsIntegration::test_missing_brikk_headers_returns_400
FAILED tests/test_coordination_stub.py::TestRequestGuardsIntegration::test_oversized_body_returns_413
FAILED tests/test_coordination_stub.py::TestEnvelopeValidationIntegration::test_missing_required_fields_returns_422
FAILED tests/test_coordination_stub.py::TestErrorHandling::test_error_responses_have_security_headers
FAILED tests/test_coordination_stub.py::TestHealthCheckEndpoint::test_health_check_returns_200
FAILED tests/test_coordination_stub.py::TestMessageTypes::test_all_message_types_accepted
FAILED tests/test_coordination_v1.py::test_coordination_v1_invalid_signature
FAILED tests/test_coordination_v1.py::test_coordination_v1_idempotency - asse...
FAILED tests/test_discovery_v1.py::test_register_service - assert 422 == 201
FAILED tests/test_discovery_v1.py::test_discover_services - assert 422 == 200
FAILED tests/test_discovery_v1.py::test_service_heartbeat - KeyError: 'id'
FAILED tests/test_discovery_v1.py::test_get_service_details - KeyError: 'id'
FAILED tests/test_economy_api_v1.py::test_get_balance - assert 404 == 200
FAILED tests/test_economy_db_v1.py::test_system_accounts_seeded - assert None...
FAILED tests/test_envelope_validation.py::TestEnvelopeValidation::test_minimal_valid_envelope
FAILED tests/test_envelope_validation.py::TestEnvelopeValidation::test_full_valid_envelope
FAILED tests/test_envelope_validation.py::TestVersionValidation::test_valid_version
FAILED tests/test_envelope_validation.py::TestMessageIdValidation::test_valid_uuid4
FAILED tests/test_envelope_validation.py::TestTimestampValidation::test_valid_rfc3339_timestamps
FAILED tests/test_envelope_validation.py::TestTypeValidation::test_valid_types
FAILED tests/test_envelope_validation.py::TestSenderRecipientValidation::test_valid_sender_recipient
FAILED tests/test_envelope_validation.py::TestSenderRecipientValidation::test_sender_without_org_id
FAILED tests/test_envelope_validation.py::TestTtlValidation::test_valid_ttl_values
FAILED tests/test_envelope_validation.py::TestExtraFieldsValidation::test_extra_fields_in_sender
FAILED tests/test_envelope_validation.py::TestMinifyFunction::test_minify_removes_none_values
FAILED tests/test_envelope_validation.py::TestMinifyFunction::test_minify_preserves_non_none_values
FAILED tests/test_envelope_validation.py::TestMinifyFunction::test_minify_nested_structures
FAILED tests/test_envelope_validation.py::TestCreateSampleEnvelope::test_create_sample_envelope_defaults
FAILED tests/test_envelope_validation.py::TestCreateSampleEnvelope::test_create_sample_envelope_custom_params
FAILED tests/test_health.py::TestHealthEndpoint::test_health_endpoint_always_returns_200
FAILED tests/test_health.py::TestHealthEndpoint::test_health_endpoint_response_format
FAILED tests/test_health.py::TestHealthEndpoint::test_health_endpoint_head_method
FAILED tests/test_health.py::TestHealthEndpoint::test_health_endpoint_content_type
FAILED tests/test_health.py::TestReadinessEndpoint::test_readiness_endpoint_all_dependencies_healthy
FAILED tests/test_health.py::TestReadinessEndpoint::test_readiness_endpoint_redis_unhealthy
FAILED tests/test_health.py::TestReadinessEndpoint::test_readiness_endpoint_redis_timeout
FAILED tests/test_health.py::TestReadinessEndpoint::test_readiness_endpoint_response_format
FAILED tests/test_health.py::TestReadinessEndpoint::test_readiness_endpoint_head_method
FAILED tests/test_health.py::TestReadinessEndpoint::test_readiness_endpoint_content_type
FAILED tests/test_health.py::TestHealthVsReadiness::test_health_vs_readiness_when_redis_down
FAILED tests/test_health.py::TestHealthVsReadiness::test_health_has_no_dependency_checks
FAILED tests/test_health.py::TestHealthVsReadiness::test_readiness_has_dependency_checks
FAILED tests/test_health.py::TestHealthEndpointIntegration::test_health_endpoints_registered
FAILED tests/test_health.py::TestHealthEndpointIntegration::test_health_endpoints_methods
FAILED tests/test_health.py::TestHealthEndpointIntegration::test_health_endpoints_no_auth_required
FAILED tests/test_health.py::TestHealthEndpointPerformance::test_health_endpoint_fast_response
FAILED tests/test_health.py::TestHealthEndpointPerformance::test_readiness_endpoint_reasonable_response_time
FAILED tests/test_health.py::TestHealthEndpointPerformance::test_health_endpoints_concurrent_requests
FAILED tests/test_health.py::TestHealthEndpointErrorHandling::test_readiness_handles_redis_import_error
FAILED tests/test_health.py::TestHealthEndpointErrorHandling::test_readiness_handles_unexpected_redis_errors
FAILED tests/test_health.py::TestHealthEndpointErrorHandling::test_health_endpoint_always_works
FAILED tests/test_integrations_v1.py::test_create_webhook - assert 422 == 201
FAILED tests/test_integrations_v1.py::test_get_webhooks - assert 422 == 200
FAILED tests/test_integrations_v1.py::test_update_webhook - KeyError: 'id'
FAILED tests/test_integrations_v1.py::test_delete_webhook - KeyError: 'id'
FAILED tests/test_integrations_v1.py::test_webhook_event_trigger - KeyError: ...
FAILED tests/test_logging_context.py::TestRequestContextMiddleware::test_auth_context_integration
FAILED tests/test_logging_context.py::TestStructuredFormatter::test_exception_formatting
FAILED tests/test_rate_limit.py::TestRateLimitIntegration::test_coordination_rate_limit_disabled
FAILED tests/test_rate_limit.py::TestRateLimitIntegration::test_coordination_rate_limit_allowed
FAILED tests/test_rate_limit.py::TestRateLimitIntegration::test_coordination_rate_limit_exceeded
FAILED tests/test_rate_limit.py::TestRateLimitIntegration::test_coordination_rate_limit_burst_behavior
FAILED tests/test_rate_limit.py::TestRateLimitIntegration::test_coordination_rate_limit_scope_switching
FAILED tests/test_rate_limit.py::TestRateLimitIntegration::test_coordination_rate_limit_redis_failure
FAILED tests/test_rate_limit.py::TestRateLimitIntegration::test_coordination_rate_limit_with_idempotency
FAILED tests/test_request_guards.py::TestBodySizeValidation::test_invalid_content_length_header
FAILED tests/test_smoke.py::test_ping_endpoint - assert 404 in [200, 302]
FAILED tests/test_smoke.py::test_basic_routes_exist - assert 404 != 404
=========== 100 failed, 167 passed, 20 skipped, 5 warnings in 11.45s ===========
